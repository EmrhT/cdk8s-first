// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Policy defines a Policy for VirtualServer and VirtualServerRoute resources.
 *
 * @schema Policy
 */
export class Policy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Policy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'k8s.nginx.org/v1',
    kind: 'Policy',
  }

  /**
   * Renders a Kubernetes manifest for "Policy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PolicyProps = {}): any {
    return {
      ...Policy.GVK,
      ...toJson_PolicyProps(props),
    };
  }

  /**
   * Defines a "Policy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PolicyProps = {}) {
    super(scope, id, {
      ...Policy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Policy.GVK,
      ...toJson_PolicyProps(resolved),
    };
  }
}

/**
 * Policy defines a Policy for VirtualServer and VirtualServerRoute resources.
 *
 * @schema Policy
 */
export interface PolicyProps {
  /**
   * @schema Policy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PolicySpec is the spec of the Policy resource. The spec includes multiple fields, where each field represents a different policy. Only one policy (field) is allowed.
   *
   * @schema Policy#spec
   */
  readonly spec?: PolicySpec;

}

/**
 * Converts an object of type 'PolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyProps(obj: PolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PolicySpec is the spec of the Policy resource. The spec includes multiple fields, where each field represents a different policy. Only one policy (field) is allowed.
 *
 * @schema PolicySpec
 */
export interface PolicySpec {
  /**
   * AccessControl defines an access policy based on the source IP of a request.
   *
   * @schema PolicySpec#accessControl
   */
  readonly accessControl?: PolicySpecAccessControl;

  /**
   * BasicAuth holds HTTP Basic authentication configuration policy status: preview
   *
   * @schema PolicySpec#basicAuth
   */
  readonly basicAuth?: PolicySpecBasicAuth;

  /**
   * EgressMTLS defines an Egress MTLS policy.
   *
   * @schema PolicySpec#egressMTLS
   */
  readonly egressMtls?: PolicySpecEgressMtls;

  /**
   * @schema PolicySpec#ingressClassName
   */
  readonly ingressClassName?: string;

  /**
   * IngressMTLS defines an Ingress MTLS policy.
   *
   * @schema PolicySpec#ingressMTLS
   */
  readonly ingressMtls?: PolicySpecIngressMtls;

  /**
   * JWTAuth holds JWT authentication configuration.
   *
   * @schema PolicySpec#jwt
   */
  readonly jwt?: PolicySpecJwt;

  /**
   * OIDC defines an Open ID Connect policy.
   *
   * @schema PolicySpec#oidc
   */
  readonly oidc?: PolicySpecOidc;

  /**
   * RateLimit defines a rate limit policy.
   *
   * @schema PolicySpec#rateLimit
   */
  readonly rateLimit?: PolicySpecRateLimit;

  /**
   * WAF defines an WAF policy.
   *
   * @schema PolicySpec#waf
   */
  readonly waf?: PolicySpecWaf;

}

/**
 * Converts an object of type 'PolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpec(obj: PolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessControl': toJson_PolicySpecAccessControl(obj.accessControl),
    'basicAuth': toJson_PolicySpecBasicAuth(obj.basicAuth),
    'egressMTLS': toJson_PolicySpecEgressMtls(obj.egressMtls),
    'ingressClassName': obj.ingressClassName,
    'ingressMTLS': toJson_PolicySpecIngressMtls(obj.ingressMtls),
    'jwt': toJson_PolicySpecJwt(obj.jwt),
    'oidc': toJson_PolicySpecOidc(obj.oidc),
    'rateLimit': toJson_PolicySpecRateLimit(obj.rateLimit),
    'waf': toJson_PolicySpecWaf(obj.waf),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccessControl defines an access policy based on the source IP of a request.
 *
 * @schema PolicySpecAccessControl
 */
export interface PolicySpecAccessControl {
  /**
   * @schema PolicySpecAccessControl#allow
   */
  readonly allow?: string[];

  /**
   * @schema PolicySpecAccessControl#deny
   */
  readonly deny?: string[];

}

/**
 * Converts an object of type 'PolicySpecAccessControl' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecAccessControl(obj: PolicySpecAccessControl | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allow': obj.allow?.map(y => y),
    'deny': obj.deny?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * BasicAuth holds HTTP Basic authentication configuration policy status: preview
 *
 * @schema PolicySpecBasicAuth
 */
export interface PolicySpecBasicAuth {
  /**
   * @schema PolicySpecBasicAuth#realm
   */
  readonly realm?: string;

  /**
   * @schema PolicySpecBasicAuth#secret
   */
  readonly secret?: string;

}

/**
 * Converts an object of type 'PolicySpecBasicAuth' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecBasicAuth(obj: PolicySpecBasicAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'realm': obj.realm,
    'secret': obj.secret,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EgressMTLS defines an Egress MTLS policy.
 *
 * @schema PolicySpecEgressMtls
 */
export interface PolicySpecEgressMtls {
  /**
   * @schema PolicySpecEgressMtls#ciphers
   */
  readonly ciphers?: string;

  /**
   * @schema PolicySpecEgressMtls#protocols
   */
  readonly protocols?: string;

  /**
   * @schema PolicySpecEgressMtls#serverName
   */
  readonly serverName?: boolean;

  /**
   * @schema PolicySpecEgressMtls#sessionReuse
   */
  readonly sessionReuse?: boolean;

  /**
   * @schema PolicySpecEgressMtls#sslName
   */
  readonly sslName?: string;

  /**
   * @schema PolicySpecEgressMtls#tlsSecret
   */
  readonly tlsSecret?: string;

  /**
   * @schema PolicySpecEgressMtls#trustedCertSecret
   */
  readonly trustedCertSecret?: string;

  /**
   * @schema PolicySpecEgressMtls#verifyDepth
   */
  readonly verifyDepth?: number;

  /**
   * @schema PolicySpecEgressMtls#verifyServer
   */
  readonly verifyServer?: boolean;

}

/**
 * Converts an object of type 'PolicySpecEgressMtls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecEgressMtls(obj: PolicySpecEgressMtls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ciphers': obj.ciphers,
    'protocols': obj.protocols,
    'serverName': obj.serverName,
    'sessionReuse': obj.sessionReuse,
    'sslName': obj.sslName,
    'tlsSecret': obj.tlsSecret,
    'trustedCertSecret': obj.trustedCertSecret,
    'verifyDepth': obj.verifyDepth,
    'verifyServer': obj.verifyServer,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IngressMTLS defines an Ingress MTLS policy.
 *
 * @schema PolicySpecIngressMtls
 */
export interface PolicySpecIngressMtls {
  /**
   * @schema PolicySpecIngressMtls#clientCertSecret
   */
  readonly clientCertSecret?: string;

  /**
   * @schema PolicySpecIngressMtls#crlFileName
   */
  readonly crlFileName?: string;

  /**
   * @schema PolicySpecIngressMtls#verifyClient
   */
  readonly verifyClient?: string;

  /**
   * @schema PolicySpecIngressMtls#verifyDepth
   */
  readonly verifyDepth?: number;

}

/**
 * Converts an object of type 'PolicySpecIngressMtls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecIngressMtls(obj: PolicySpecIngressMtls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCertSecret': obj.clientCertSecret,
    'crlFileName': obj.crlFileName,
    'verifyClient': obj.verifyClient,
    'verifyDepth': obj.verifyDepth,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * JWTAuth holds JWT authentication configuration.
 *
 * @schema PolicySpecJwt
 */
export interface PolicySpecJwt {
  /**
   * @schema PolicySpecJwt#jwksURI
   */
  readonly jwksUri?: string;

  /**
   * @schema PolicySpecJwt#keyCache
   */
  readonly keyCache?: string;

  /**
   * @schema PolicySpecJwt#realm
   */
  readonly realm?: string;

  /**
   * @schema PolicySpecJwt#secret
   */
  readonly secret?: string;

  /**
   * @schema PolicySpecJwt#token
   */
  readonly token?: string;

}

/**
 * Converts an object of type 'PolicySpecJwt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecJwt(obj: PolicySpecJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jwksURI': obj.jwksUri,
    'keyCache': obj.keyCache,
    'realm': obj.realm,
    'secret': obj.secret,
    'token': obj.token,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * OIDC defines an Open ID Connect policy.
 *
 * @schema PolicySpecOidc
 */
export interface PolicySpecOidc {
  /**
   * @schema PolicySpecOidc#accessTokenEnable
   */
  readonly accessTokenEnable?: boolean;

  /**
   * @schema PolicySpecOidc#authEndpoint
   */
  readonly authEndpoint?: string;

  /**
   * @schema PolicySpecOidc#authExtraArgs
   */
  readonly authExtraArgs?: string[];

  /**
   * @schema PolicySpecOidc#clientID
   */
  readonly clientId?: string;

  /**
   * @schema PolicySpecOidc#clientSecret
   */
  readonly clientSecret?: string;

  /**
   * @schema PolicySpecOidc#jwksURI
   */
  readonly jwksUri?: string;

  /**
   * @schema PolicySpecOidc#redirectURI
   */
  readonly redirectUri?: string;

  /**
   * @schema PolicySpecOidc#scope
   */
  readonly scope?: string;

  /**
   * @schema PolicySpecOidc#tokenEndpoint
   */
  readonly tokenEndpoint?: string;

  /**
   * @schema PolicySpecOidc#zoneSyncLeeway
   */
  readonly zoneSyncLeeway?: number;

}

/**
 * Converts an object of type 'PolicySpecOidc' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecOidc(obj: PolicySpecOidc | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessTokenEnable': obj.accessTokenEnable,
    'authEndpoint': obj.authEndpoint,
    'authExtraArgs': obj.authExtraArgs?.map(y => y),
    'clientID': obj.clientId,
    'clientSecret': obj.clientSecret,
    'jwksURI': obj.jwksUri,
    'redirectURI': obj.redirectUri,
    'scope': obj.scope,
    'tokenEndpoint': obj.tokenEndpoint,
    'zoneSyncLeeway': obj.zoneSyncLeeway,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RateLimit defines a rate limit policy.
 *
 * @schema PolicySpecRateLimit
 */
export interface PolicySpecRateLimit {
  /**
   * @schema PolicySpecRateLimit#burst
   */
  readonly burst?: number;

  /**
   * @schema PolicySpecRateLimit#delay
   */
  readonly delay?: number;

  /**
   * @schema PolicySpecRateLimit#dryRun
   */
  readonly dryRun?: boolean;

  /**
   * @schema PolicySpecRateLimit#key
   */
  readonly key?: string;

  /**
   * @schema PolicySpecRateLimit#logLevel
   */
  readonly logLevel?: string;

  /**
   * @schema PolicySpecRateLimit#noDelay
   */
  readonly noDelay?: boolean;

  /**
   * @schema PolicySpecRateLimit#rate
   */
  readonly rate?: string;

  /**
   * @schema PolicySpecRateLimit#rejectCode
   */
  readonly rejectCode?: number;

  /**
   * @schema PolicySpecRateLimit#zoneSize
   */
  readonly zoneSize?: string;

}

/**
 * Converts an object of type 'PolicySpecRateLimit' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecRateLimit(obj: PolicySpecRateLimit | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'burst': obj.burst,
    'delay': obj.delay,
    'dryRun': obj.dryRun,
    'key': obj.key,
    'logLevel': obj.logLevel,
    'noDelay': obj.noDelay,
    'rate': obj.rate,
    'rejectCode': obj.rejectCode,
    'zoneSize': obj.zoneSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * WAF defines an WAF policy.
 *
 * @schema PolicySpecWaf
 */
export interface PolicySpecWaf {
  /**
   * @schema PolicySpecWaf#apBundle
   */
  readonly apBundle?: string;

  /**
   * @schema PolicySpecWaf#apPolicy
   */
  readonly apPolicy?: string;

  /**
   * @schema PolicySpecWaf#enable
   */
  readonly enable?: boolean;

  /**
   * SecurityLog defines the security log of a WAF policy.
   *
   * @schema PolicySpecWaf#securityLog
   */
  readonly securityLog?: PolicySpecWafSecurityLog;

  /**
   * @schema PolicySpecWaf#securityLogs
   */
  readonly securityLogs?: PolicySpecWafSecurityLogs[];

}

/**
 * Converts an object of type 'PolicySpecWaf' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecWaf(obj: PolicySpecWaf | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apBundle': obj.apBundle,
    'apPolicy': obj.apPolicy,
    'enable': obj.enable,
    'securityLog': toJson_PolicySpecWafSecurityLog(obj.securityLog),
    'securityLogs': obj.securityLogs?.map(y => toJson_PolicySpecWafSecurityLogs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityLog defines the security log of a WAF policy.
 *
 * @schema PolicySpecWafSecurityLog
 */
export interface PolicySpecWafSecurityLog {
  /**
   * @schema PolicySpecWafSecurityLog#apLogConf
   */
  readonly apLogConf?: string;

  /**
   * @schema PolicySpecWafSecurityLog#enable
   */
  readonly enable?: boolean;

  /**
   * @schema PolicySpecWafSecurityLog#logDest
   */
  readonly logDest?: string;

}

/**
 * Converts an object of type 'PolicySpecWafSecurityLog' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecWafSecurityLog(obj: PolicySpecWafSecurityLog | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apLogConf': obj.apLogConf,
    'enable': obj.enable,
    'logDest': obj.logDest,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SecurityLog defines the security log of a WAF policy.
 *
 * @schema PolicySpecWafSecurityLogs
 */
export interface PolicySpecWafSecurityLogs {
  /**
   * @schema PolicySpecWafSecurityLogs#apLogConf
   */
  readonly apLogConf?: string;

  /**
   * @schema PolicySpecWafSecurityLogs#enable
   */
  readonly enable?: boolean;

  /**
   * @schema PolicySpecWafSecurityLogs#logDest
   */
  readonly logDest?: string;

}

/**
 * Converts an object of type 'PolicySpecWafSecurityLogs' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicySpecWafSecurityLogs(obj: PolicySpecWafSecurityLogs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apLogConf': obj.apLogConf,
    'enable': obj.enable,
    'logDest': obj.logDest,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * Policy defines a Policy for VirtualServer and VirtualServerRoute resources.
 *
 * @schema PolicyV1Alpha1
 */
export class PolicyV1Alpha1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PolicyV1Alpha1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'k8s.nginx.org/v1alpha1',
    kind: 'Policy',
  }

  /**
   * Renders a Kubernetes manifest for "PolicyV1Alpha1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PolicyV1Alpha1Props = {}): any {
    return {
      ...PolicyV1Alpha1.GVK,
      ...toJson_PolicyV1Alpha1Props(props),
    };
  }

  /**
   * Defines a "PolicyV1Alpha1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PolicyV1Alpha1Props = {}) {
    super(scope, id, {
      ...PolicyV1Alpha1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PolicyV1Alpha1.GVK,
      ...toJson_PolicyV1Alpha1Props(resolved),
    };
  }
}

/**
 * Policy defines a Policy for VirtualServer and VirtualServerRoute resources.
 *
 * @schema PolicyV1Alpha1
 */
export interface PolicyV1Alpha1Props {
  /**
   * @schema PolicyV1Alpha1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * PolicySpec is the spec of the Policy resource. The spec includes multiple fields, where each field represents a different policy. Only one policy (field) is allowed.
   *
   * @schema PolicyV1Alpha1#spec
   */
  readonly spec?: PolicyV1Alpha1Spec;

}

/**
 * Converts an object of type 'PolicyV1Alpha1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyV1Alpha1Props(obj: PolicyV1Alpha1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PolicyV1Alpha1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PolicySpec is the spec of the Policy resource. The spec includes multiple fields, where each field represents a different policy. Only one policy (field) is allowed.
 *
 * @schema PolicyV1Alpha1Spec
 */
export interface PolicyV1Alpha1Spec {
  /**
   * AccessControl defines an access policy based on the source IP of a request.
   *
   * @schema PolicyV1Alpha1Spec#accessControl
   */
  readonly accessControl?: PolicyV1Alpha1SpecAccessControl;

  /**
   * EgressMTLS defines an Egress MTLS policy.
   *
   * @schema PolicyV1Alpha1Spec#egressMTLS
   */
  readonly egressMtls?: PolicyV1Alpha1SpecEgressMtls;

  /**
   * IngressMTLS defines an Ingress MTLS policy.
   *
   * @schema PolicyV1Alpha1Spec#ingressMTLS
   */
  readonly ingressMtls?: PolicyV1Alpha1SpecIngressMtls;

  /**
   * JWTAuth holds JWT authentication configuration.
   *
   * @schema PolicyV1Alpha1Spec#jwt
   */
  readonly jwt?: PolicyV1Alpha1SpecJwt;

  /**
   * RateLimit defines a rate limit policy.
   *
   * @schema PolicyV1Alpha1Spec#rateLimit
   */
  readonly rateLimit?: PolicyV1Alpha1SpecRateLimit;

}

/**
 * Converts an object of type 'PolicyV1Alpha1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyV1Alpha1Spec(obj: PolicyV1Alpha1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessControl': toJson_PolicyV1Alpha1SpecAccessControl(obj.accessControl),
    'egressMTLS': toJson_PolicyV1Alpha1SpecEgressMtls(obj.egressMtls),
    'ingressMTLS': toJson_PolicyV1Alpha1SpecIngressMtls(obj.ingressMtls),
    'jwt': toJson_PolicyV1Alpha1SpecJwt(obj.jwt),
    'rateLimit': toJson_PolicyV1Alpha1SpecRateLimit(obj.rateLimit),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AccessControl defines an access policy based on the source IP of a request.
 *
 * @schema PolicyV1Alpha1SpecAccessControl
 */
export interface PolicyV1Alpha1SpecAccessControl {
  /**
   * @schema PolicyV1Alpha1SpecAccessControl#allow
   */
  readonly allow?: string[];

  /**
   * @schema PolicyV1Alpha1SpecAccessControl#deny
   */
  readonly deny?: string[];

}

/**
 * Converts an object of type 'PolicyV1Alpha1SpecAccessControl' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyV1Alpha1SpecAccessControl(obj: PolicyV1Alpha1SpecAccessControl | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allow': obj.allow?.map(y => y),
    'deny': obj.deny?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * EgressMTLS defines an Egress MTLS policy.
 *
 * @schema PolicyV1Alpha1SpecEgressMtls
 */
export interface PolicyV1Alpha1SpecEgressMtls {
  /**
   * @schema PolicyV1Alpha1SpecEgressMtls#ciphers
   */
  readonly ciphers?: string;

  /**
   * @schema PolicyV1Alpha1SpecEgressMtls#protocols
   */
  readonly protocols?: string;

  /**
   * @schema PolicyV1Alpha1SpecEgressMtls#serverName
   */
  readonly serverName?: boolean;

  /**
   * @schema PolicyV1Alpha1SpecEgressMtls#sessionReuse
   */
  readonly sessionReuse?: boolean;

  /**
   * @schema PolicyV1Alpha1SpecEgressMtls#sslName
   */
  readonly sslName?: string;

  /**
   * @schema PolicyV1Alpha1SpecEgressMtls#tlsSecret
   */
  readonly tlsSecret?: string;

  /**
   * @schema PolicyV1Alpha1SpecEgressMtls#trustedCertSecret
   */
  readonly trustedCertSecret?: string;

  /**
   * @schema PolicyV1Alpha1SpecEgressMtls#verifyDepth
   */
  readonly verifyDepth?: number;

  /**
   * @schema PolicyV1Alpha1SpecEgressMtls#verifyServer
   */
  readonly verifyServer?: boolean;

}

/**
 * Converts an object of type 'PolicyV1Alpha1SpecEgressMtls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyV1Alpha1SpecEgressMtls(obj: PolicyV1Alpha1SpecEgressMtls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ciphers': obj.ciphers,
    'protocols': obj.protocols,
    'serverName': obj.serverName,
    'sessionReuse': obj.sessionReuse,
    'sslName': obj.sslName,
    'tlsSecret': obj.tlsSecret,
    'trustedCertSecret': obj.trustedCertSecret,
    'verifyDepth': obj.verifyDepth,
    'verifyServer': obj.verifyServer,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * IngressMTLS defines an Ingress MTLS policy.
 *
 * @schema PolicyV1Alpha1SpecIngressMtls
 */
export interface PolicyV1Alpha1SpecIngressMtls {
  /**
   * @schema PolicyV1Alpha1SpecIngressMtls#clientCertSecret
   */
  readonly clientCertSecret?: string;

  /**
   * @schema PolicyV1Alpha1SpecIngressMtls#verifyClient
   */
  readonly verifyClient?: string;

  /**
   * @schema PolicyV1Alpha1SpecIngressMtls#verifyDepth
   */
  readonly verifyDepth?: number;

}

/**
 * Converts an object of type 'PolicyV1Alpha1SpecIngressMtls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyV1Alpha1SpecIngressMtls(obj: PolicyV1Alpha1SpecIngressMtls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCertSecret': obj.clientCertSecret,
    'verifyClient': obj.verifyClient,
    'verifyDepth': obj.verifyDepth,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * JWTAuth holds JWT authentication configuration.
 *
 * @schema PolicyV1Alpha1SpecJwt
 */
export interface PolicyV1Alpha1SpecJwt {
  /**
   * @schema PolicyV1Alpha1SpecJwt#realm
   */
  readonly realm?: string;

  /**
   * @schema PolicyV1Alpha1SpecJwt#secret
   */
  readonly secret?: string;

  /**
   * @schema PolicyV1Alpha1SpecJwt#token
   */
  readonly token?: string;

}

/**
 * Converts an object of type 'PolicyV1Alpha1SpecJwt' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyV1Alpha1SpecJwt(obj: PolicyV1Alpha1SpecJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'realm': obj.realm,
    'secret': obj.secret,
    'token': obj.token,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * RateLimit defines a rate limit policy.
 *
 * @schema PolicyV1Alpha1SpecRateLimit
 */
export interface PolicyV1Alpha1SpecRateLimit {
  /**
   * @schema PolicyV1Alpha1SpecRateLimit#burst
   */
  readonly burst?: number;

  /**
   * @schema PolicyV1Alpha1SpecRateLimit#delay
   */
  readonly delay?: number;

  /**
   * @schema PolicyV1Alpha1SpecRateLimit#dryRun
   */
  readonly dryRun?: boolean;

  /**
   * @schema PolicyV1Alpha1SpecRateLimit#key
   */
  readonly key?: string;

  /**
   * @schema PolicyV1Alpha1SpecRateLimit#logLevel
   */
  readonly logLevel?: string;

  /**
   * @schema PolicyV1Alpha1SpecRateLimit#noDelay
   */
  readonly noDelay?: boolean;

  /**
   * @schema PolicyV1Alpha1SpecRateLimit#rate
   */
  readonly rate?: string;

  /**
   * @schema PolicyV1Alpha1SpecRateLimit#rejectCode
   */
  readonly rejectCode?: number;

  /**
   * @schema PolicyV1Alpha1SpecRateLimit#zoneSize
   */
  readonly zoneSize?: string;

}

/**
 * Converts an object of type 'PolicyV1Alpha1SpecRateLimit' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_PolicyV1Alpha1SpecRateLimit(obj: PolicyV1Alpha1SpecRateLimit | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'burst': obj.burst,
    'delay': obj.delay,
    'dryRun': obj.dryRun,
    'key': obj.key,
    'logLevel': obj.logLevel,
    'noDelay': obj.noDelay,
    'rate': obj.rate,
    'rejectCode': obj.rejectCode,
    'zoneSize': obj.zoneSize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * TransportServer defines the TransportServer resource.
 *
 * @schema TransportServer
 */
export class TransportServer extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TransportServer"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'k8s.nginx.org/v1',
    kind: 'TransportServer',
  }

  /**
   * Renders a Kubernetes manifest for "TransportServer".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TransportServerProps = {}): any {
    return {
      ...TransportServer.GVK,
      ...toJson_TransportServerProps(props),
    };
  }

  /**
   * Defines a "TransportServer" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TransportServerProps = {}) {
    super(scope, id, {
      ...TransportServer.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TransportServer.GVK,
      ...toJson_TransportServerProps(resolved),
    };
  }
}

/**
 * TransportServer defines the TransportServer resource.
 *
 * @schema TransportServer
 */
export interface TransportServerProps {
  /**
   * @schema TransportServer#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TransportServerSpec is the spec of the TransportServer resource.
   *
   * @schema TransportServer#spec
   */
  readonly spec?: TransportServerSpec;

}

/**
 * Converts an object of type 'TransportServerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransportServerProps(obj: TransportServerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TransportServerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransportServerSpec is the spec of the TransportServer resource.
 *
 * @schema TransportServerSpec
 */
export interface TransportServerSpec {
  /**
   * TransportServerAction defines an action.
   *
   * @schema TransportServerSpec#action
   */
  readonly action?: TransportServerSpecAction;

  /**
   * @schema TransportServerSpec#host
   */
  readonly host?: string;

  /**
   * @schema TransportServerSpec#ingressClassName
   */
  readonly ingressClassName?: string;

  /**
   * TransportServerListener defines a listener for a TransportServer.
   *
   * @schema TransportServerSpec#listener
   */
  readonly listener?: TransportServerSpecListener;

  /**
   * @schema TransportServerSpec#serverSnippets
   */
  readonly serverSnippets?: string;

  /**
   * SessionParameters defines session parameters.
   *
   * @schema TransportServerSpec#sessionParameters
   */
  readonly sessionParameters?: TransportServerSpecSessionParameters;

  /**
   * @schema TransportServerSpec#streamSnippets
   */
  readonly streamSnippets?: string;

  /**
   * TransportServerTLS defines TransportServerTLS configuration for a TransportServer.
   *
   * @schema TransportServerSpec#tls
   */
  readonly tls?: TransportServerSpecTls;

  /**
   * UpstreamParameters defines parameters for an upstream.
   *
   * @schema TransportServerSpec#upstreamParameters
   */
  readonly upstreamParameters?: TransportServerSpecUpstreamParameters;

  /**
   * @schema TransportServerSpec#upstreams
   */
  readonly upstreams?: TransportServerSpecUpstreams[];

}

/**
 * Converts an object of type 'TransportServerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransportServerSpec(obj: TransportServerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': toJson_TransportServerSpecAction(obj.action),
    'host': obj.host,
    'ingressClassName': obj.ingressClassName,
    'listener': toJson_TransportServerSpecListener(obj.listener),
    'serverSnippets': obj.serverSnippets,
    'sessionParameters': toJson_TransportServerSpecSessionParameters(obj.sessionParameters),
    'streamSnippets': obj.streamSnippets,
    'tls': toJson_TransportServerSpecTls(obj.tls),
    'upstreamParameters': toJson_TransportServerSpecUpstreamParameters(obj.upstreamParameters),
    'upstreams': obj.upstreams?.map(y => toJson_TransportServerSpecUpstreams(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransportServerAction defines an action.
 *
 * @schema TransportServerSpecAction
 */
export interface TransportServerSpecAction {
  /**
   * @schema TransportServerSpecAction#pass
   */
  readonly pass?: string;

}

/**
 * Converts an object of type 'TransportServerSpecAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransportServerSpecAction(obj: TransportServerSpecAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pass': obj.pass,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransportServerListener defines a listener for a TransportServer.
 *
 * @schema TransportServerSpecListener
 */
export interface TransportServerSpecListener {
  /**
   * @schema TransportServerSpecListener#name
   */
  readonly name?: string;

  /**
   * @schema TransportServerSpecListener#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'TransportServerSpecListener' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransportServerSpecListener(obj: TransportServerSpecListener | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SessionParameters defines session parameters.
 *
 * @schema TransportServerSpecSessionParameters
 */
export interface TransportServerSpecSessionParameters {
  /**
   * @schema TransportServerSpecSessionParameters#timeout
   */
  readonly timeout?: string;

}

/**
 * Converts an object of type 'TransportServerSpecSessionParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransportServerSpecSessionParameters(obj: TransportServerSpecSessionParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransportServerTLS defines TransportServerTLS configuration for a TransportServer.
 *
 * @schema TransportServerSpecTls
 */
export interface TransportServerSpecTls {
  /**
   * @schema TransportServerSpecTls#secret
   */
  readonly secret?: string;

}

/**
 * Converts an object of type 'TransportServerSpecTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransportServerSpecTls(obj: TransportServerSpecTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secret': obj.secret,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UpstreamParameters defines parameters for an upstream.
 *
 * @schema TransportServerSpecUpstreamParameters
 */
export interface TransportServerSpecUpstreamParameters {
  /**
   * @schema TransportServerSpecUpstreamParameters#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * @schema TransportServerSpecUpstreamParameters#nextUpstream
   */
  readonly nextUpstream?: boolean;

  /**
   * @schema TransportServerSpecUpstreamParameters#nextUpstreamTimeout
   */
  readonly nextUpstreamTimeout?: string;

  /**
   * @schema TransportServerSpecUpstreamParameters#nextUpstreamTries
   */
  readonly nextUpstreamTries?: number;

  /**
   * @schema TransportServerSpecUpstreamParameters#udpRequests
   */
  readonly udpRequests?: number;

  /**
   * @schema TransportServerSpecUpstreamParameters#udpResponses
   */
  readonly udpResponses?: number;

}

/**
 * Converts an object of type 'TransportServerSpecUpstreamParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransportServerSpecUpstreamParameters(obj: TransportServerSpecUpstreamParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'nextUpstream': obj.nextUpstream,
    'nextUpstreamTimeout': obj.nextUpstreamTimeout,
    'nextUpstreamTries': obj.nextUpstreamTries,
    'udpRequests': obj.udpRequests,
    'udpResponses': obj.udpResponses,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransportServerUpstream defines an upstream.
 *
 * @schema TransportServerSpecUpstreams
 */
export interface TransportServerSpecUpstreams {
  /**
   * @schema TransportServerSpecUpstreams#failTimeout
   */
  readonly failTimeout?: string;

  /**
   * TransportServerHealthCheck defines the parameters for active Upstream HealthChecks.
   *
   * @schema TransportServerSpecUpstreams#healthCheck
   */
  readonly healthCheck?: TransportServerSpecUpstreamsHealthCheck;

  /**
   * @schema TransportServerSpecUpstreams#loadBalancingMethod
   */
  readonly loadBalancingMethod?: string;

  /**
   * @schema TransportServerSpecUpstreams#maxConns
   */
  readonly maxConns?: number;

  /**
   * @schema TransportServerSpecUpstreams#maxFails
   */
  readonly maxFails?: number;

  /**
   * @schema TransportServerSpecUpstreams#name
   */
  readonly name?: string;

  /**
   * @schema TransportServerSpecUpstreams#port
   */
  readonly port?: number;

  /**
   * @schema TransportServerSpecUpstreams#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'TransportServerSpecUpstreams' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransportServerSpecUpstreams(obj: TransportServerSpecUpstreams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failTimeout': obj.failTimeout,
    'healthCheck': toJson_TransportServerSpecUpstreamsHealthCheck(obj.healthCheck),
    'loadBalancingMethod': obj.loadBalancingMethod,
    'maxConns': obj.maxConns,
    'maxFails': obj.maxFails,
    'name': obj.name,
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransportServerHealthCheck defines the parameters for active Upstream HealthChecks.
 *
 * @schema TransportServerSpecUpstreamsHealthCheck
 */
export interface TransportServerSpecUpstreamsHealthCheck {
  /**
   * @schema TransportServerSpecUpstreamsHealthCheck#enable
   */
  readonly enable?: boolean;

  /**
   * @schema TransportServerSpecUpstreamsHealthCheck#fails
   */
  readonly fails?: number;

  /**
   * @schema TransportServerSpecUpstreamsHealthCheck#interval
   */
  readonly interval?: string;

  /**
   * @schema TransportServerSpecUpstreamsHealthCheck#jitter
   */
  readonly jitter?: string;

  /**
   * TransportServerMatch defines the parameters of a custom health check.
   *
   * @schema TransportServerSpecUpstreamsHealthCheck#match
   */
  readonly match?: TransportServerSpecUpstreamsHealthCheckMatch;

  /**
   * @schema TransportServerSpecUpstreamsHealthCheck#passes
   */
  readonly passes?: number;

  /**
   * @schema TransportServerSpecUpstreamsHealthCheck#port
   */
  readonly port?: number;

  /**
   * @schema TransportServerSpecUpstreamsHealthCheck#timeout
   */
  readonly timeout?: string;

}

/**
 * Converts an object of type 'TransportServerSpecUpstreamsHealthCheck' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransportServerSpecUpstreamsHealthCheck(obj: TransportServerSpecUpstreamsHealthCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enable': obj.enable,
    'fails': obj.fails,
    'interval': obj.interval,
    'jitter': obj.jitter,
    'match': toJson_TransportServerSpecUpstreamsHealthCheckMatch(obj.match),
    'passes': obj.passes,
    'port': obj.port,
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransportServerMatch defines the parameters of a custom health check.
 *
 * @schema TransportServerSpecUpstreamsHealthCheckMatch
 */
export interface TransportServerSpecUpstreamsHealthCheckMatch {
  /**
   * @schema TransportServerSpecUpstreamsHealthCheckMatch#expect
   */
  readonly expect?: string;

  /**
   * @schema TransportServerSpecUpstreamsHealthCheckMatch#send
   */
  readonly send?: string;

}

/**
 * Converts an object of type 'TransportServerSpecUpstreamsHealthCheckMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransportServerSpecUpstreamsHealthCheckMatch(obj: TransportServerSpecUpstreamsHealthCheckMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expect': obj.expect,
    'send': obj.send,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * TransportServer defines the TransportServer resource.
 *
 * @schema TransportServerV1Alpha1
 */
export class TransportServerV1Alpha1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "TransportServerV1Alpha1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'k8s.nginx.org/v1alpha1',
    kind: 'TransportServer',
  }

  /**
   * Renders a Kubernetes manifest for "TransportServerV1Alpha1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TransportServerV1Alpha1Props = {}): any {
    return {
      ...TransportServerV1Alpha1.GVK,
      ...toJson_TransportServerV1Alpha1Props(props),
    };
  }

  /**
   * Defines a "TransportServerV1Alpha1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TransportServerV1Alpha1Props = {}) {
    super(scope, id, {
      ...TransportServerV1Alpha1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...TransportServerV1Alpha1.GVK,
      ...toJson_TransportServerV1Alpha1Props(resolved),
    };
  }
}

/**
 * TransportServer defines the TransportServer resource.
 *
 * @schema TransportServerV1Alpha1
 */
export interface TransportServerV1Alpha1Props {
  /**
   * @schema TransportServerV1Alpha1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TransportServerSpec is the spec of the TransportServer resource.
   *
   * @schema TransportServerV1Alpha1#spec
   */
  readonly spec?: TransportServerV1Alpha1Spec;

}

/**
 * Converts an object of type 'TransportServerV1Alpha1Props' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransportServerV1Alpha1Props(obj: TransportServerV1Alpha1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TransportServerV1Alpha1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransportServerSpec is the spec of the TransportServer resource.
 *
 * @schema TransportServerV1Alpha1Spec
 */
export interface TransportServerV1Alpha1Spec {
  /**
   * TransportServerAction defines an action.
   *
   * @schema TransportServerV1Alpha1Spec#action
   */
  readonly action?: TransportServerV1Alpha1SpecAction;

  /**
   * @schema TransportServerV1Alpha1Spec#host
   */
  readonly host?: string;

  /**
   * @schema TransportServerV1Alpha1Spec#ingressClassName
   */
  readonly ingressClassName?: string;

  /**
   * TransportServerListener defines a listener for a TransportServer.
   *
   * @schema TransportServerV1Alpha1Spec#listener
   */
  readonly listener?: TransportServerV1Alpha1SpecListener;

  /**
   * @schema TransportServerV1Alpha1Spec#serverSnippets
   */
  readonly serverSnippets?: string;

  /**
   * SessionParameters defines session parameters.
   *
   * @schema TransportServerV1Alpha1Spec#sessionParameters
   */
  readonly sessionParameters?: TransportServerV1Alpha1SpecSessionParameters;

  /**
   * @schema TransportServerV1Alpha1Spec#streamSnippets
   */
  readonly streamSnippets?: string;

  /**
   * TransportServerTLS defines TransportServerTLS configuration for a TransportServer.
   *
   * @schema TransportServerV1Alpha1Spec#tls
   */
  readonly tls?: TransportServerV1Alpha1SpecTls;

  /**
   * UpstreamParameters defines parameters for an upstream.
   *
   * @schema TransportServerV1Alpha1Spec#upstreamParameters
   */
  readonly upstreamParameters?: TransportServerV1Alpha1SpecUpstreamParameters;

  /**
   * @schema TransportServerV1Alpha1Spec#upstreams
   */
  readonly upstreams?: TransportServerV1Alpha1SpecUpstreams[];

}

/**
 * Converts an object of type 'TransportServerV1Alpha1Spec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransportServerV1Alpha1Spec(obj: TransportServerV1Alpha1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': toJson_TransportServerV1Alpha1SpecAction(obj.action),
    'host': obj.host,
    'ingressClassName': obj.ingressClassName,
    'listener': toJson_TransportServerV1Alpha1SpecListener(obj.listener),
    'serverSnippets': obj.serverSnippets,
    'sessionParameters': toJson_TransportServerV1Alpha1SpecSessionParameters(obj.sessionParameters),
    'streamSnippets': obj.streamSnippets,
    'tls': toJson_TransportServerV1Alpha1SpecTls(obj.tls),
    'upstreamParameters': toJson_TransportServerV1Alpha1SpecUpstreamParameters(obj.upstreamParameters),
    'upstreams': obj.upstreams?.map(y => toJson_TransportServerV1Alpha1SpecUpstreams(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransportServerAction defines an action.
 *
 * @schema TransportServerV1Alpha1SpecAction
 */
export interface TransportServerV1Alpha1SpecAction {
  /**
   * @schema TransportServerV1Alpha1SpecAction#pass
   */
  readonly pass?: string;

}

/**
 * Converts an object of type 'TransportServerV1Alpha1SpecAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransportServerV1Alpha1SpecAction(obj: TransportServerV1Alpha1SpecAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pass': obj.pass,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransportServerListener defines a listener for a TransportServer.
 *
 * @schema TransportServerV1Alpha1SpecListener
 */
export interface TransportServerV1Alpha1SpecListener {
  /**
   * @schema TransportServerV1Alpha1SpecListener#name
   */
  readonly name?: string;

  /**
   * @schema TransportServerV1Alpha1SpecListener#protocol
   */
  readonly protocol?: string;

}

/**
 * Converts an object of type 'TransportServerV1Alpha1SpecListener' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransportServerV1Alpha1SpecListener(obj: TransportServerV1Alpha1SpecListener | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'protocol': obj.protocol,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SessionParameters defines session parameters.
 *
 * @schema TransportServerV1Alpha1SpecSessionParameters
 */
export interface TransportServerV1Alpha1SpecSessionParameters {
  /**
   * @schema TransportServerV1Alpha1SpecSessionParameters#timeout
   */
  readonly timeout?: string;

}

/**
 * Converts an object of type 'TransportServerV1Alpha1SpecSessionParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransportServerV1Alpha1SpecSessionParameters(obj: TransportServerV1Alpha1SpecSessionParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransportServerTLS defines TransportServerTLS configuration for a TransportServer.
 *
 * @schema TransportServerV1Alpha1SpecTls
 */
export interface TransportServerV1Alpha1SpecTls {
  /**
   * @schema TransportServerV1Alpha1SpecTls#secret
   */
  readonly secret?: string;

}

/**
 * Converts an object of type 'TransportServerV1Alpha1SpecTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransportServerV1Alpha1SpecTls(obj: TransportServerV1Alpha1SpecTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secret': obj.secret,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UpstreamParameters defines parameters for an upstream.
 *
 * @schema TransportServerV1Alpha1SpecUpstreamParameters
 */
export interface TransportServerV1Alpha1SpecUpstreamParameters {
  /**
   * @schema TransportServerV1Alpha1SpecUpstreamParameters#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * @schema TransportServerV1Alpha1SpecUpstreamParameters#nextUpstream
   */
  readonly nextUpstream?: boolean;

  /**
   * @schema TransportServerV1Alpha1SpecUpstreamParameters#nextUpstreamTimeout
   */
  readonly nextUpstreamTimeout?: string;

  /**
   * @schema TransportServerV1Alpha1SpecUpstreamParameters#nextUpstreamTries
   */
  readonly nextUpstreamTries?: number;

  /**
   * @schema TransportServerV1Alpha1SpecUpstreamParameters#udpRequests
   */
  readonly udpRequests?: number;

  /**
   * @schema TransportServerV1Alpha1SpecUpstreamParameters#udpResponses
   */
  readonly udpResponses?: number;

}

/**
 * Converts an object of type 'TransportServerV1Alpha1SpecUpstreamParameters' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransportServerV1Alpha1SpecUpstreamParameters(obj: TransportServerV1Alpha1SpecUpstreamParameters | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTimeout': obj.connectTimeout,
    'nextUpstream': obj.nextUpstream,
    'nextUpstreamTimeout': obj.nextUpstreamTimeout,
    'nextUpstreamTries': obj.nextUpstreamTries,
    'udpRequests': obj.udpRequests,
    'udpResponses': obj.udpResponses,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransportServerUpstream defines an upstream.
 *
 * @schema TransportServerV1Alpha1SpecUpstreams
 */
export interface TransportServerV1Alpha1SpecUpstreams {
  /**
   * @schema TransportServerV1Alpha1SpecUpstreams#failTimeout
   */
  readonly failTimeout?: string;

  /**
   * TransportServerHealthCheck defines the parameters for active Upstream HealthChecks.
   *
   * @schema TransportServerV1Alpha1SpecUpstreams#healthCheck
   */
  readonly healthCheck?: TransportServerV1Alpha1SpecUpstreamsHealthCheck;

  /**
   * @schema TransportServerV1Alpha1SpecUpstreams#loadBalancingMethod
   */
  readonly loadBalancingMethod?: string;

  /**
   * @schema TransportServerV1Alpha1SpecUpstreams#maxConns
   */
  readonly maxConns?: number;

  /**
   * @schema TransportServerV1Alpha1SpecUpstreams#maxFails
   */
  readonly maxFails?: number;

  /**
   * @schema TransportServerV1Alpha1SpecUpstreams#name
   */
  readonly name?: string;

  /**
   * @schema TransportServerV1Alpha1SpecUpstreams#port
   */
  readonly port?: number;

  /**
   * @schema TransportServerV1Alpha1SpecUpstreams#service
   */
  readonly service?: string;

}

/**
 * Converts an object of type 'TransportServerV1Alpha1SpecUpstreams' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransportServerV1Alpha1SpecUpstreams(obj: TransportServerV1Alpha1SpecUpstreams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'failTimeout': obj.failTimeout,
    'healthCheck': toJson_TransportServerV1Alpha1SpecUpstreamsHealthCheck(obj.healthCheck),
    'loadBalancingMethod': obj.loadBalancingMethod,
    'maxConns': obj.maxConns,
    'maxFails': obj.maxFails,
    'name': obj.name,
    'port': obj.port,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransportServerHealthCheck defines the parameters for active Upstream HealthChecks.
 *
 * @schema TransportServerV1Alpha1SpecUpstreamsHealthCheck
 */
export interface TransportServerV1Alpha1SpecUpstreamsHealthCheck {
  /**
   * @schema TransportServerV1Alpha1SpecUpstreamsHealthCheck#enable
   */
  readonly enable?: boolean;

  /**
   * @schema TransportServerV1Alpha1SpecUpstreamsHealthCheck#fails
   */
  readonly fails?: number;

  /**
   * @schema TransportServerV1Alpha1SpecUpstreamsHealthCheck#interval
   */
  readonly interval?: string;

  /**
   * @schema TransportServerV1Alpha1SpecUpstreamsHealthCheck#jitter
   */
  readonly jitter?: string;

  /**
   * TransportServerMatch defines the parameters of a custom health check.
   *
   * @schema TransportServerV1Alpha1SpecUpstreamsHealthCheck#match
   */
  readonly match?: TransportServerV1Alpha1SpecUpstreamsHealthCheckMatch;

  /**
   * @schema TransportServerV1Alpha1SpecUpstreamsHealthCheck#passes
   */
  readonly passes?: number;

  /**
   * @schema TransportServerV1Alpha1SpecUpstreamsHealthCheck#port
   */
  readonly port?: number;

  /**
   * @schema TransportServerV1Alpha1SpecUpstreamsHealthCheck#timeout
   */
  readonly timeout?: string;

}

/**
 * Converts an object of type 'TransportServerV1Alpha1SpecUpstreamsHealthCheck' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransportServerV1Alpha1SpecUpstreamsHealthCheck(obj: TransportServerV1Alpha1SpecUpstreamsHealthCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enable': obj.enable,
    'fails': obj.fails,
    'interval': obj.interval,
    'jitter': obj.jitter,
    'match': toJson_TransportServerV1Alpha1SpecUpstreamsHealthCheckMatch(obj.match),
    'passes': obj.passes,
    'port': obj.port,
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TransportServerMatch defines the parameters of a custom health check.
 *
 * @schema TransportServerV1Alpha1SpecUpstreamsHealthCheckMatch
 */
export interface TransportServerV1Alpha1SpecUpstreamsHealthCheckMatch {
  /**
   * @schema TransportServerV1Alpha1SpecUpstreamsHealthCheckMatch#expect
   */
  readonly expect?: string;

  /**
   * @schema TransportServerV1Alpha1SpecUpstreamsHealthCheckMatch#send
   */
  readonly send?: string;

}

/**
 * Converts an object of type 'TransportServerV1Alpha1SpecUpstreamsHealthCheckMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_TransportServerV1Alpha1SpecUpstreamsHealthCheckMatch(obj: TransportServerV1Alpha1SpecUpstreamsHealthCheckMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'expect': obj.expect,
    'send': obj.send,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * VirtualServer defines the VirtualServer resource.
 *
 * @schema VirtualServer
 */
export class VirtualServer extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VirtualServer"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'k8s.nginx.org/v1',
    kind: 'VirtualServer',
  }

  /**
   * Renders a Kubernetes manifest for "VirtualServer".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VirtualServerProps = {}): any {
    return {
      ...VirtualServer.GVK,
      ...toJson_VirtualServerProps(props),
    };
  }

  /**
   * Defines a "VirtualServer" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VirtualServerProps = {}) {
    super(scope, id, {
      ...VirtualServer.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...VirtualServer.GVK,
      ...toJson_VirtualServerProps(resolved),
    };
  }
}

/**
 * VirtualServer defines the VirtualServer resource.
 *
 * @schema VirtualServer
 */
export interface VirtualServerProps {
  /**
   * @schema VirtualServer#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VirtualServerSpec is the spec of the VirtualServer resource.
   *
   * @schema VirtualServer#spec
   */
  readonly spec?: VirtualServerSpec;

}

/**
 * Converts an object of type 'VirtualServerProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerProps(obj: VirtualServerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VirtualServerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VirtualServerSpec is the spec of the VirtualServer resource.
 *
 * @schema VirtualServerSpec
 */
export interface VirtualServerSpec {
  /**
   * @schema VirtualServerSpec#dos
   */
  readonly dos?: string;

  /**
   * ExternalDNS defines externaldns sub-resource of a virtual server.
   *
   * @schema VirtualServerSpec#externalDNS
   */
  readonly externalDns?: VirtualServerSpecExternalDns;

  /**
   * @schema VirtualServerSpec#gunzip
   */
  readonly gunzip?: boolean;

  /**
   * @schema VirtualServerSpec#host
   */
  readonly host?: string;

  /**
   * @schema VirtualServerSpec#http-snippets
   */
  readonly httpSnippets?: string;

  /**
   * @schema VirtualServerSpec#ingressClassName
   */
  readonly ingressClassName?: string;

  /**
   * InternalRoute allows for the configuration of internal routing.
   *
   * @schema VirtualServerSpec#internalRoute
   */
  readonly internalRoute?: boolean;

  /**
   * VirtualServerListener references a custom http and/or https listener defined in GlobalConfiguration.
   *
   * @schema VirtualServerSpec#listener
   */
  readonly listener?: VirtualServerSpecListener;

  /**
   * @schema VirtualServerSpec#policies
   */
  readonly policies?: VirtualServerSpecPolicies[];

  /**
   * @schema VirtualServerSpec#routes
   */
  readonly routes?: VirtualServerSpecRoutes[];

  /**
   * @schema VirtualServerSpec#server-snippets
   */
  readonly serverSnippets?: string;

  /**
   * TLS defines TLS configuration for a VirtualServer.
   *
   * @schema VirtualServerSpec#tls
   */
  readonly tls?: VirtualServerSpecTls;

  /**
   * @schema VirtualServerSpec#upstreams
   */
  readonly upstreams?: VirtualServerSpecUpstreams[];

}

/**
 * Converts an object of type 'VirtualServerSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpec(obj: VirtualServerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dos': obj.dos,
    'externalDNS': toJson_VirtualServerSpecExternalDns(obj.externalDns),
    'gunzip': obj.gunzip,
    'host': obj.host,
    'http-snippets': obj.httpSnippets,
    'ingressClassName': obj.ingressClassName,
    'internalRoute': obj.internalRoute,
    'listener': toJson_VirtualServerSpecListener(obj.listener),
    'policies': obj.policies?.map(y => toJson_VirtualServerSpecPolicies(y)),
    'routes': obj.routes?.map(y => toJson_VirtualServerSpecRoutes(y)),
    'server-snippets': obj.serverSnippets,
    'tls': toJson_VirtualServerSpecTls(obj.tls),
    'upstreams': obj.upstreams?.map(y => toJson_VirtualServerSpecUpstreams(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExternalDNS defines externaldns sub-resource of a virtual server.
 *
 * @schema VirtualServerSpecExternalDns
 */
export interface VirtualServerSpecExternalDns {
  /**
   * @schema VirtualServerSpecExternalDns#enable
   */
  readonly enable?: boolean;

  /**
   * Labels stores labels defined for the Endpoint
   *
   * @schema VirtualServerSpecExternalDns#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * ProviderSpecific stores provider specific config
   *
   * @schema VirtualServerSpecExternalDns#providerSpecific
   */
  readonly providerSpecific?: VirtualServerSpecExternalDnsProviderSpecific[];

  /**
   * TTL for the record
   *
   * @schema VirtualServerSpecExternalDns#recordTTL
   */
  readonly recordTtl?: number;

  /**
   * @schema VirtualServerSpecExternalDns#recordType
   */
  readonly recordType?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecExternalDns' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecExternalDns(obj: VirtualServerSpecExternalDns | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enable': obj.enable,
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'providerSpecific': obj.providerSpecific?.map(y => toJson_VirtualServerSpecExternalDnsProviderSpecific(y)),
    'recordTTL': obj.recordTtl,
    'recordType': obj.recordType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VirtualServerListener references a custom http and/or https listener defined in GlobalConfiguration.
 *
 * @schema VirtualServerSpecListener
 */
export interface VirtualServerSpecListener {
  /**
   * @schema VirtualServerSpecListener#http
   */
  readonly http?: string;

  /**
   * @schema VirtualServerSpecListener#https
   */
  readonly https?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecListener' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecListener(obj: VirtualServerSpecListener | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'http': obj.http,
    'https': obj.https,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PolicyReference references a policy by name and an optional namespace.
 *
 * @schema VirtualServerSpecPolicies
 */
export interface VirtualServerSpecPolicies {
  /**
   * @schema VirtualServerSpecPolicies#name
   */
  readonly name?: string;

  /**
   * @schema VirtualServerSpecPolicies#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecPolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecPolicies(obj: VirtualServerSpecPolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Route defines a route.
 *
 * @schema VirtualServerSpecRoutes
 */
export interface VirtualServerSpecRoutes {
  /**
   * Action defines an action.
   *
   * @schema VirtualServerSpecRoutes#action
   */
  readonly action?: VirtualServerSpecRoutesAction;

  /**
   * @schema VirtualServerSpecRoutes#dos
   */
  readonly dos?: string;

  /**
   * @schema VirtualServerSpecRoutes#errorPages
   */
  readonly errorPages?: VirtualServerSpecRoutesErrorPages[];

  /**
   * @schema VirtualServerSpecRoutes#location-snippets
   */
  readonly locationSnippets?: string;

  /**
   * @schema VirtualServerSpecRoutes#matches
   */
  readonly matches?: VirtualServerSpecRoutesMatches[];

  /**
   * @schema VirtualServerSpecRoutes#path
   */
  readonly path?: string;

  /**
   * @schema VirtualServerSpecRoutes#policies
   */
  readonly policies?: VirtualServerSpecRoutesPolicies[];

  /**
   * @schema VirtualServerSpecRoutes#route
   */
  readonly route?: string;

  /**
   * @schema VirtualServerSpecRoutes#splits
   */
  readonly splits?: VirtualServerSpecRoutesSplits[];

}

/**
 * Converts an object of type 'VirtualServerSpecRoutes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutes(obj: VirtualServerSpecRoutes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': toJson_VirtualServerSpecRoutesAction(obj.action),
    'dos': obj.dos,
    'errorPages': obj.errorPages?.map(y => toJson_VirtualServerSpecRoutesErrorPages(y)),
    'location-snippets': obj.locationSnippets,
    'matches': obj.matches?.map(y => toJson_VirtualServerSpecRoutesMatches(y)),
    'path': obj.path,
    'policies': obj.policies?.map(y => toJson_VirtualServerSpecRoutesPolicies(y)),
    'route': obj.route,
    'splits': obj.splits?.map(y => toJson_VirtualServerSpecRoutesSplits(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLS defines TLS configuration for a VirtualServer.
 *
 * @schema VirtualServerSpecTls
 */
export interface VirtualServerSpecTls {
  /**
   * CertManager defines a cert manager config for a TLS.
   *
   * @schema VirtualServerSpecTls#cert-manager
   */
  readonly certManager?: VirtualServerSpecTlsCertManager;

  /**
   * TLSRedirect defines a redirect for a TLS.
   *
   * @schema VirtualServerSpecTls#redirect
   */
  readonly redirect?: VirtualServerSpecTlsRedirect;

  /**
   * @schema VirtualServerSpecTls#secret
   */
  readonly secret?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecTls(obj: VirtualServerSpecTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cert-manager': toJson_VirtualServerSpecTlsCertManager(obj.certManager),
    'redirect': toJson_VirtualServerSpecTlsRedirect(obj.redirect),
    'secret': obj.secret,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Upstream defines an upstream.
 *
 * @schema VirtualServerSpecUpstreams
 */
export interface VirtualServerSpecUpstreams {
  /**
   * @schema VirtualServerSpecUpstreams#buffer-size
   */
  readonly bufferSize?: string;

  /**
   * @schema VirtualServerSpecUpstreams#buffering
   */
  readonly buffering?: boolean;

  /**
   * UpstreamBuffers defines Buffer Configuration for an Upstream.
   *
   * @schema VirtualServerSpecUpstreams#buffers
   */
  readonly buffers?: VirtualServerSpecUpstreamsBuffers;

  /**
   * @schema VirtualServerSpecUpstreams#client-max-body-size
   */
  readonly clientMaxBodySize?: string;

  /**
   * @schema VirtualServerSpecUpstreams#connect-timeout
   */
  readonly connectTimeout?: string;

  /**
   * @schema VirtualServerSpecUpstreams#fail-timeout
   */
  readonly failTimeout?: string;

  /**
   * HealthCheck defines the parameters for active Upstream HealthChecks.
   *
   * @schema VirtualServerSpecUpstreams#healthCheck
   */
  readonly healthCheck?: VirtualServerSpecUpstreamsHealthCheck;

  /**
   * @schema VirtualServerSpecUpstreams#keepalive
   */
  readonly keepalive?: number;

  /**
   * @schema VirtualServerSpecUpstreams#lb-method
   */
  readonly lbMethod?: string;

  /**
   * @schema VirtualServerSpecUpstreams#max-conns
   */
  readonly maxConns?: number;

  /**
   * @schema VirtualServerSpecUpstreams#max-fails
   */
  readonly maxFails?: number;

  /**
   * @schema VirtualServerSpecUpstreams#name
   */
  readonly name?: string;

  /**
   * @schema VirtualServerSpecUpstreams#next-upstream
   */
  readonly nextUpstream?: string;

  /**
   * @schema VirtualServerSpecUpstreams#next-upstream-timeout
   */
  readonly nextUpstreamTimeout?: string;

  /**
   * @schema VirtualServerSpecUpstreams#next-upstream-tries
   */
  readonly nextUpstreamTries?: number;

  /**
   * @schema VirtualServerSpecUpstreams#ntlm
   */
  readonly ntlm?: boolean;

  /**
   * @schema VirtualServerSpecUpstreams#port
   */
  readonly port?: number;

  /**
   * UpstreamQueue defines Queue Configuration for an Upstream.
   *
   * @schema VirtualServerSpecUpstreams#queue
   */
  readonly queue?: VirtualServerSpecUpstreamsQueue;

  /**
   * @schema VirtualServerSpecUpstreams#read-timeout
   */
  readonly readTimeout?: string;

  /**
   * @schema VirtualServerSpecUpstreams#send-timeout
   */
  readonly sendTimeout?: string;

  /**
   * @schema VirtualServerSpecUpstreams#service
   */
  readonly service?: string;

  /**
   * SessionCookie defines the parameters for session persistence.
   *
   * @schema VirtualServerSpecUpstreams#sessionCookie
   */
  readonly sessionCookie?: VirtualServerSpecUpstreamsSessionCookie;

  /**
   * @schema VirtualServerSpecUpstreams#slow-start
   */
  readonly slowStart?: string;

  /**
   * @schema VirtualServerSpecUpstreams#subselector
   */
  readonly subselector?: { [key: string]: string };

  /**
   * UpstreamTLS defines a TLS configuration for an Upstream.
   *
   * @schema VirtualServerSpecUpstreams#tls
   */
  readonly tls?: VirtualServerSpecUpstreamsTls;

  /**
   * @schema VirtualServerSpecUpstreams#type
   */
  readonly type?: string;

  /**
   * @schema VirtualServerSpecUpstreams#use-cluster-ip
   */
  readonly useClusterIp?: boolean;

}

/**
 * Converts an object of type 'VirtualServerSpecUpstreams' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecUpstreams(obj: VirtualServerSpecUpstreams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'buffer-size': obj.bufferSize,
    'buffering': obj.buffering,
    'buffers': toJson_VirtualServerSpecUpstreamsBuffers(obj.buffers),
    'client-max-body-size': obj.clientMaxBodySize,
    'connect-timeout': obj.connectTimeout,
    'fail-timeout': obj.failTimeout,
    'healthCheck': toJson_VirtualServerSpecUpstreamsHealthCheck(obj.healthCheck),
    'keepalive': obj.keepalive,
    'lb-method': obj.lbMethod,
    'max-conns': obj.maxConns,
    'max-fails': obj.maxFails,
    'name': obj.name,
    'next-upstream': obj.nextUpstream,
    'next-upstream-timeout': obj.nextUpstreamTimeout,
    'next-upstream-tries': obj.nextUpstreamTries,
    'ntlm': obj.ntlm,
    'port': obj.port,
    'queue': toJson_VirtualServerSpecUpstreamsQueue(obj.queue),
    'read-timeout': obj.readTimeout,
    'send-timeout': obj.sendTimeout,
    'service': obj.service,
    'sessionCookie': toJson_VirtualServerSpecUpstreamsSessionCookie(obj.sessionCookie),
    'slow-start': obj.slowStart,
    'subselector': ((obj.subselector) === undefined) ? undefined : (Object.entries(obj.subselector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'tls': toJson_VirtualServerSpecUpstreamsTls(obj.tls),
    'type': obj.type,
    'use-cluster-ip': obj.useClusterIp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProviderSpecificProperty defines specific property for using with ExternalDNS sub-resource.
 *
 * @schema VirtualServerSpecExternalDnsProviderSpecific
 */
export interface VirtualServerSpecExternalDnsProviderSpecific {
  /**
   * Name of the property
   *
   * @schema VirtualServerSpecExternalDnsProviderSpecific#name
   */
  readonly name?: string;

  /**
   * Value of the property
   *
   * @schema VirtualServerSpecExternalDnsProviderSpecific#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecExternalDnsProviderSpecific' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecExternalDnsProviderSpecific(obj: VirtualServerSpecExternalDnsProviderSpecific | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Action defines an action.
 *
 * @schema VirtualServerSpecRoutesAction
 */
export interface VirtualServerSpecRoutesAction {
  /**
   * @schema VirtualServerSpecRoutesAction#pass
   */
  readonly pass?: string;

  /**
   * ActionProxy defines a proxy in an Action.
   *
   * @schema VirtualServerSpecRoutesAction#proxy
   */
  readonly proxy?: VirtualServerSpecRoutesActionProxy;

  /**
   * ActionRedirect defines a redirect in an Action.
   *
   * @schema VirtualServerSpecRoutesAction#redirect
   */
  readonly redirect?: VirtualServerSpecRoutesActionRedirect;

  /**
   * ActionReturn defines a return in an Action.
   *
   * @schema VirtualServerSpecRoutesAction#return
   */
  readonly return?: VirtualServerSpecRoutesActionReturn;

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesAction(obj: VirtualServerSpecRoutesAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pass': obj.pass,
    'proxy': toJson_VirtualServerSpecRoutesActionProxy(obj.proxy),
    'redirect': toJson_VirtualServerSpecRoutesActionRedirect(obj.redirect),
    'return': toJson_VirtualServerSpecRoutesActionReturn(obj.return),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ErrorPage defines an ErrorPage in a Route.
 *
 * @schema VirtualServerSpecRoutesErrorPages
 */
export interface VirtualServerSpecRoutesErrorPages {
  /**
   * @schema VirtualServerSpecRoutesErrorPages#codes
   */
  readonly codes?: number[];

  /**
   * ErrorPageRedirect defines a redirect for an ErrorPage.
   *
   * @schema VirtualServerSpecRoutesErrorPages#redirect
   */
  readonly redirect?: VirtualServerSpecRoutesErrorPagesRedirect;

  /**
   * ErrorPageReturn defines a return for an ErrorPage.
   *
   * @schema VirtualServerSpecRoutesErrorPages#return
   */
  readonly return?: VirtualServerSpecRoutesErrorPagesReturn;

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesErrorPages' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesErrorPages(obj: VirtualServerSpecRoutesErrorPages | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'codes': obj.codes?.map(y => y),
    'redirect': toJson_VirtualServerSpecRoutesErrorPagesRedirect(obj.redirect),
    'return': toJson_VirtualServerSpecRoutesErrorPagesReturn(obj.return),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Match defines a match.
 *
 * @schema VirtualServerSpecRoutesMatches
 */
export interface VirtualServerSpecRoutesMatches {
  /**
   * Action defines an action.
   *
   * @schema VirtualServerSpecRoutesMatches#action
   */
  readonly action?: VirtualServerSpecRoutesMatchesAction;

  /**
   * @schema VirtualServerSpecRoutesMatches#conditions
   */
  readonly conditions?: VirtualServerSpecRoutesMatchesConditions[];

  /**
   * @schema VirtualServerSpecRoutesMatches#splits
   */
  readonly splits?: VirtualServerSpecRoutesMatchesSplits[];

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesMatches' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesMatches(obj: VirtualServerSpecRoutesMatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': toJson_VirtualServerSpecRoutesMatchesAction(obj.action),
    'conditions': obj.conditions?.map(y => toJson_VirtualServerSpecRoutesMatchesConditions(y)),
    'splits': obj.splits?.map(y => toJson_VirtualServerSpecRoutesMatchesSplits(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PolicyReference references a policy by name and an optional namespace.
 *
 * @schema VirtualServerSpecRoutesPolicies
 */
export interface VirtualServerSpecRoutesPolicies {
  /**
   * @schema VirtualServerSpecRoutesPolicies#name
   */
  readonly name?: string;

  /**
   * @schema VirtualServerSpecRoutesPolicies#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesPolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesPolicies(obj: VirtualServerSpecRoutesPolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Split defines a split.
 *
 * @schema VirtualServerSpecRoutesSplits
 */
export interface VirtualServerSpecRoutesSplits {
  /**
   * Action defines an action.
   *
   * @schema VirtualServerSpecRoutesSplits#action
   */
  readonly action?: VirtualServerSpecRoutesSplitsAction;

  /**
   * @schema VirtualServerSpecRoutesSplits#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesSplits' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesSplits(obj: VirtualServerSpecRoutesSplits | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': toJson_VirtualServerSpecRoutesSplitsAction(obj.action),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertManager defines a cert manager config for a TLS.
 *
 * @schema VirtualServerSpecTlsCertManager
 */
export interface VirtualServerSpecTlsCertManager {
  /**
   * @schema VirtualServerSpecTlsCertManager#cluster-issuer
   */
  readonly clusterIssuer?: string;

  /**
   * @schema VirtualServerSpecTlsCertManager#common-name
   */
  readonly commonName?: string;

  /**
   * @schema VirtualServerSpecTlsCertManager#duration
   */
  readonly duration?: string;

  /**
   * @schema VirtualServerSpecTlsCertManager#issue-temp-cert
   */
  readonly issueTempCert?: boolean;

  /**
   * @schema VirtualServerSpecTlsCertManager#issuer
   */
  readonly issuer?: string;

  /**
   * @schema VirtualServerSpecTlsCertManager#issuer-group
   */
  readonly issuerGroup?: string;

  /**
   * @schema VirtualServerSpecTlsCertManager#issuer-kind
   */
  readonly issuerKind?: string;

  /**
   * @schema VirtualServerSpecTlsCertManager#renew-before
   */
  readonly renewBefore?: string;

  /**
   * @schema VirtualServerSpecTlsCertManager#usages
   */
  readonly usages?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecTlsCertManager' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecTlsCertManager(obj: VirtualServerSpecTlsCertManager | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cluster-issuer': obj.clusterIssuer,
    'common-name': obj.commonName,
    'duration': obj.duration,
    'issue-temp-cert': obj.issueTempCert,
    'issuer': obj.issuer,
    'issuer-group': obj.issuerGroup,
    'issuer-kind': obj.issuerKind,
    'renew-before': obj.renewBefore,
    'usages': obj.usages,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * TLSRedirect defines a redirect for a TLS.
 *
 * @schema VirtualServerSpecTlsRedirect
 */
export interface VirtualServerSpecTlsRedirect {
  /**
   * @schema VirtualServerSpecTlsRedirect#basedOn
   */
  readonly basedOn?: string;

  /**
   * @schema VirtualServerSpecTlsRedirect#code
   */
  readonly code?: number;

  /**
   * @schema VirtualServerSpecTlsRedirect#enable
   */
  readonly enable?: boolean;

}

/**
 * Converts an object of type 'VirtualServerSpecTlsRedirect' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecTlsRedirect(obj: VirtualServerSpecTlsRedirect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'basedOn': obj.basedOn,
    'code': obj.code,
    'enable': obj.enable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UpstreamBuffers defines Buffer Configuration for an Upstream.
 *
 * @schema VirtualServerSpecUpstreamsBuffers
 */
export interface VirtualServerSpecUpstreamsBuffers {
  /**
   * @schema VirtualServerSpecUpstreamsBuffers#number
   */
  readonly number?: number;

  /**
   * @schema VirtualServerSpecUpstreamsBuffers#size
   */
  readonly size?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecUpstreamsBuffers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecUpstreamsBuffers(obj: VirtualServerSpecUpstreamsBuffers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
    'size': obj.size,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HealthCheck defines the parameters for active Upstream HealthChecks.
 *
 * @schema VirtualServerSpecUpstreamsHealthCheck
 */
export interface VirtualServerSpecUpstreamsHealthCheck {
  /**
   * @schema VirtualServerSpecUpstreamsHealthCheck#connect-timeout
   */
  readonly connectTimeout?: string;

  /**
   * @schema VirtualServerSpecUpstreamsHealthCheck#enable
   */
  readonly enable?: boolean;

  /**
   * @schema VirtualServerSpecUpstreamsHealthCheck#fails
   */
  readonly fails?: number;

  /**
   * @schema VirtualServerSpecUpstreamsHealthCheck#grpcService
   */
  readonly grpcService?: string;

  /**
   * @schema VirtualServerSpecUpstreamsHealthCheck#grpcStatus
   */
  readonly grpcStatus?: number;

  /**
   * @schema VirtualServerSpecUpstreamsHealthCheck#headers
   */
  readonly headers?: VirtualServerSpecUpstreamsHealthCheckHeaders[];

  /**
   * @schema VirtualServerSpecUpstreamsHealthCheck#interval
   */
  readonly interval?: string;

  /**
   * @schema VirtualServerSpecUpstreamsHealthCheck#jitter
   */
  readonly jitter?: string;

  /**
   * @schema VirtualServerSpecUpstreamsHealthCheck#keepalive-time
   */
  readonly keepaliveTime?: string;

  /**
   * @schema VirtualServerSpecUpstreamsHealthCheck#mandatory
   */
  readonly mandatory?: boolean;

  /**
   * @schema VirtualServerSpecUpstreamsHealthCheck#passes
   */
  readonly passes?: number;

  /**
   * @schema VirtualServerSpecUpstreamsHealthCheck#path
   */
  readonly path?: string;

  /**
   * @schema VirtualServerSpecUpstreamsHealthCheck#persistent
   */
  readonly persistent?: boolean;

  /**
   * @schema VirtualServerSpecUpstreamsHealthCheck#port
   */
  readonly port?: number;

  /**
   * @schema VirtualServerSpecUpstreamsHealthCheck#read-timeout
   */
  readonly readTimeout?: string;

  /**
   * @schema VirtualServerSpecUpstreamsHealthCheck#send-timeout
   */
  readonly sendTimeout?: string;

  /**
   * @schema VirtualServerSpecUpstreamsHealthCheck#statusMatch
   */
  readonly statusMatch?: string;

  /**
   * UpstreamTLS defines a TLS configuration for an Upstream.
   *
   * @schema VirtualServerSpecUpstreamsHealthCheck#tls
   */
  readonly tls?: VirtualServerSpecUpstreamsHealthCheckTls;

}

/**
 * Converts an object of type 'VirtualServerSpecUpstreamsHealthCheck' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecUpstreamsHealthCheck(obj: VirtualServerSpecUpstreamsHealthCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connect-timeout': obj.connectTimeout,
    'enable': obj.enable,
    'fails': obj.fails,
    'grpcService': obj.grpcService,
    'grpcStatus': obj.grpcStatus,
    'headers': obj.headers?.map(y => toJson_VirtualServerSpecUpstreamsHealthCheckHeaders(y)),
    'interval': obj.interval,
    'jitter': obj.jitter,
    'keepalive-time': obj.keepaliveTime,
    'mandatory': obj.mandatory,
    'passes': obj.passes,
    'path': obj.path,
    'persistent': obj.persistent,
    'port': obj.port,
    'read-timeout': obj.readTimeout,
    'send-timeout': obj.sendTimeout,
    'statusMatch': obj.statusMatch,
    'tls': toJson_VirtualServerSpecUpstreamsHealthCheckTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UpstreamQueue defines Queue Configuration for an Upstream.
 *
 * @schema VirtualServerSpecUpstreamsQueue
 */
export interface VirtualServerSpecUpstreamsQueue {
  /**
   * @schema VirtualServerSpecUpstreamsQueue#size
   */
  readonly size?: number;

  /**
   * @schema VirtualServerSpecUpstreamsQueue#timeout
   */
  readonly timeout?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecUpstreamsQueue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecUpstreamsQueue(obj: VirtualServerSpecUpstreamsQueue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'size': obj.size,
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SessionCookie defines the parameters for session persistence.
 *
 * @schema VirtualServerSpecUpstreamsSessionCookie
 */
export interface VirtualServerSpecUpstreamsSessionCookie {
  /**
   * @schema VirtualServerSpecUpstreamsSessionCookie#domain
   */
  readonly domain?: string;

  /**
   * @schema VirtualServerSpecUpstreamsSessionCookie#enable
   */
  readonly enable?: boolean;

  /**
   * @schema VirtualServerSpecUpstreamsSessionCookie#expires
   */
  readonly expires?: string;

  /**
   * @schema VirtualServerSpecUpstreamsSessionCookie#httpOnly
   */
  readonly httpOnly?: boolean;

  /**
   * @schema VirtualServerSpecUpstreamsSessionCookie#name
   */
  readonly name?: string;

  /**
   * @schema VirtualServerSpecUpstreamsSessionCookie#path
   */
  readonly path?: string;

  /**
   * @schema VirtualServerSpecUpstreamsSessionCookie#samesite
   */
  readonly samesite?: string;

  /**
   * @schema VirtualServerSpecUpstreamsSessionCookie#secure
   */
  readonly secure?: boolean;

}

/**
 * Converts an object of type 'VirtualServerSpecUpstreamsSessionCookie' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecUpstreamsSessionCookie(obj: VirtualServerSpecUpstreamsSessionCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domain': obj.domain,
    'enable': obj.enable,
    'expires': obj.expires,
    'httpOnly': obj.httpOnly,
    'name': obj.name,
    'path': obj.path,
    'samesite': obj.samesite,
    'secure': obj.secure,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UpstreamTLS defines a TLS configuration for an Upstream.
 *
 * @schema VirtualServerSpecUpstreamsTls
 */
export interface VirtualServerSpecUpstreamsTls {
  /**
   * @schema VirtualServerSpecUpstreamsTls#enable
   */
  readonly enable?: boolean;

}

/**
 * Converts an object of type 'VirtualServerSpecUpstreamsTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecUpstreamsTls(obj: VirtualServerSpecUpstreamsTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enable': obj.enable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ActionProxy defines a proxy in an Action.
 *
 * @schema VirtualServerSpecRoutesActionProxy
 */
export interface VirtualServerSpecRoutesActionProxy {
  /**
   * ProxyRequestHeaders defines the request headers manipulation in an ActionProxy.
   *
   * @schema VirtualServerSpecRoutesActionProxy#requestHeaders
   */
  readonly requestHeaders?: VirtualServerSpecRoutesActionProxyRequestHeaders;

  /**
   * ProxyResponseHeaders defines the response headers manipulation in an ActionProxy.
   *
   * @schema VirtualServerSpecRoutesActionProxy#responseHeaders
   */
  readonly responseHeaders?: VirtualServerSpecRoutesActionProxyResponseHeaders;

  /**
   * @schema VirtualServerSpecRoutesActionProxy#rewritePath
   */
  readonly rewritePath?: string;

  /**
   * @schema VirtualServerSpecRoutesActionProxy#upstream
   */
  readonly upstream?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesActionProxy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesActionProxy(obj: VirtualServerSpecRoutesActionProxy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'requestHeaders': toJson_VirtualServerSpecRoutesActionProxyRequestHeaders(obj.requestHeaders),
    'responseHeaders': toJson_VirtualServerSpecRoutesActionProxyResponseHeaders(obj.responseHeaders),
    'rewritePath': obj.rewritePath,
    'upstream': obj.upstream,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ActionRedirect defines a redirect in an Action.
 *
 * @schema VirtualServerSpecRoutesActionRedirect
 */
export interface VirtualServerSpecRoutesActionRedirect {
  /**
   * @schema VirtualServerSpecRoutesActionRedirect#code
   */
  readonly code?: number;

  /**
   * @schema VirtualServerSpecRoutesActionRedirect#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesActionRedirect' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesActionRedirect(obj: VirtualServerSpecRoutesActionRedirect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'code': obj.code,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ActionReturn defines a return in an Action.
 *
 * @schema VirtualServerSpecRoutesActionReturn
 */
export interface VirtualServerSpecRoutesActionReturn {
  /**
   * @schema VirtualServerSpecRoutesActionReturn#body
   */
  readonly body?: string;

  /**
   * @schema VirtualServerSpecRoutesActionReturn#code
   */
  readonly code?: number;

  /**
   * @schema VirtualServerSpecRoutesActionReturn#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesActionReturn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesActionReturn(obj: VirtualServerSpecRoutesActionReturn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'body': obj.body,
    'code': obj.code,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ErrorPageRedirect defines a redirect for an ErrorPage.
 *
 * @schema VirtualServerSpecRoutesErrorPagesRedirect
 */
export interface VirtualServerSpecRoutesErrorPagesRedirect {
  /**
   * @schema VirtualServerSpecRoutesErrorPagesRedirect#code
   */
  readonly code?: number;

  /**
   * @schema VirtualServerSpecRoutesErrorPagesRedirect#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesErrorPagesRedirect' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesErrorPagesRedirect(obj: VirtualServerSpecRoutesErrorPagesRedirect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'code': obj.code,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ErrorPageReturn defines a return for an ErrorPage.
 *
 * @schema VirtualServerSpecRoutesErrorPagesReturn
 */
export interface VirtualServerSpecRoutesErrorPagesReturn {
  /**
   * @schema VirtualServerSpecRoutesErrorPagesReturn#body
   */
  readonly body?: string;

  /**
   * @schema VirtualServerSpecRoutesErrorPagesReturn#code
   */
  readonly code?: number;

  /**
   * @schema VirtualServerSpecRoutesErrorPagesReturn#headers
   */
  readonly headers?: VirtualServerSpecRoutesErrorPagesReturnHeaders[];

  /**
   * @schema VirtualServerSpecRoutesErrorPagesReturn#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesErrorPagesReturn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesErrorPagesReturn(obj: VirtualServerSpecRoutesErrorPagesReturn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'body': obj.body,
    'code': obj.code,
    'headers': obj.headers?.map(y => toJson_VirtualServerSpecRoutesErrorPagesReturnHeaders(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Action defines an action.
 *
 * @schema VirtualServerSpecRoutesMatchesAction
 */
export interface VirtualServerSpecRoutesMatchesAction {
  /**
   * @schema VirtualServerSpecRoutesMatchesAction#pass
   */
  readonly pass?: string;

  /**
   * ActionProxy defines a proxy in an Action.
   *
   * @schema VirtualServerSpecRoutesMatchesAction#proxy
   */
  readonly proxy?: VirtualServerSpecRoutesMatchesActionProxy;

  /**
   * ActionRedirect defines a redirect in an Action.
   *
   * @schema VirtualServerSpecRoutesMatchesAction#redirect
   */
  readonly redirect?: VirtualServerSpecRoutesMatchesActionRedirect;

  /**
   * ActionReturn defines a return in an Action.
   *
   * @schema VirtualServerSpecRoutesMatchesAction#return
   */
  readonly return?: VirtualServerSpecRoutesMatchesActionReturn;

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesMatchesAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesMatchesAction(obj: VirtualServerSpecRoutesMatchesAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pass': obj.pass,
    'proxy': toJson_VirtualServerSpecRoutesMatchesActionProxy(obj.proxy),
    'redirect': toJson_VirtualServerSpecRoutesMatchesActionRedirect(obj.redirect),
    'return': toJson_VirtualServerSpecRoutesMatchesActionReturn(obj.return),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Condition defines a condition in a MatchRule.
 *
 * @schema VirtualServerSpecRoutesMatchesConditions
 */
export interface VirtualServerSpecRoutesMatchesConditions {
  /**
   * @schema VirtualServerSpecRoutesMatchesConditions#argument
   */
  readonly argument?: string;

  /**
   * @schema VirtualServerSpecRoutesMatchesConditions#cookie
   */
  readonly cookie?: string;

  /**
   * @schema VirtualServerSpecRoutesMatchesConditions#header
   */
  readonly header?: string;

  /**
   * @schema VirtualServerSpecRoutesMatchesConditions#value
   */
  readonly value?: string;

  /**
   * @schema VirtualServerSpecRoutesMatchesConditions#variable
   */
  readonly variable?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesMatchesConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesMatchesConditions(obj: VirtualServerSpecRoutesMatchesConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'argument': obj.argument,
    'cookie': obj.cookie,
    'header': obj.header,
    'value': obj.value,
    'variable': obj.variable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Split defines a split.
 *
 * @schema VirtualServerSpecRoutesMatchesSplits
 */
export interface VirtualServerSpecRoutesMatchesSplits {
  /**
   * Action defines an action.
   *
   * @schema VirtualServerSpecRoutesMatchesSplits#action
   */
  readonly action?: VirtualServerSpecRoutesMatchesSplitsAction;

  /**
   * @schema VirtualServerSpecRoutesMatchesSplits#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesMatchesSplits' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesMatchesSplits(obj: VirtualServerSpecRoutesMatchesSplits | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': toJson_VirtualServerSpecRoutesMatchesSplitsAction(obj.action),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Action defines an action.
 *
 * @schema VirtualServerSpecRoutesSplitsAction
 */
export interface VirtualServerSpecRoutesSplitsAction {
  /**
   * @schema VirtualServerSpecRoutesSplitsAction#pass
   */
  readonly pass?: string;

  /**
   * ActionProxy defines a proxy in an Action.
   *
   * @schema VirtualServerSpecRoutesSplitsAction#proxy
   */
  readonly proxy?: VirtualServerSpecRoutesSplitsActionProxy;

  /**
   * ActionRedirect defines a redirect in an Action.
   *
   * @schema VirtualServerSpecRoutesSplitsAction#redirect
   */
  readonly redirect?: VirtualServerSpecRoutesSplitsActionRedirect;

  /**
   * ActionReturn defines a return in an Action.
   *
   * @schema VirtualServerSpecRoutesSplitsAction#return
   */
  readonly return?: VirtualServerSpecRoutesSplitsActionReturn;

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesSplitsAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesSplitsAction(obj: VirtualServerSpecRoutesSplitsAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pass': obj.pass,
    'proxy': toJson_VirtualServerSpecRoutesSplitsActionProxy(obj.proxy),
    'redirect': toJson_VirtualServerSpecRoutesSplitsActionRedirect(obj.redirect),
    'return': toJson_VirtualServerSpecRoutesSplitsActionReturn(obj.return),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Header defines an HTTP Header.
 *
 * @schema VirtualServerSpecUpstreamsHealthCheckHeaders
 */
export interface VirtualServerSpecUpstreamsHealthCheckHeaders {
  /**
   * @schema VirtualServerSpecUpstreamsHealthCheckHeaders#name
   */
  readonly name?: string;

  /**
   * @schema VirtualServerSpecUpstreamsHealthCheckHeaders#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecUpstreamsHealthCheckHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecUpstreamsHealthCheckHeaders(obj: VirtualServerSpecUpstreamsHealthCheckHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UpstreamTLS defines a TLS configuration for an Upstream.
 *
 * @schema VirtualServerSpecUpstreamsHealthCheckTls
 */
export interface VirtualServerSpecUpstreamsHealthCheckTls {
  /**
   * @schema VirtualServerSpecUpstreamsHealthCheckTls#enable
   */
  readonly enable?: boolean;

}

/**
 * Converts an object of type 'VirtualServerSpecUpstreamsHealthCheckTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecUpstreamsHealthCheckTls(obj: VirtualServerSpecUpstreamsHealthCheckTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enable': obj.enable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProxyRequestHeaders defines the request headers manipulation in an ActionProxy.
 *
 * @schema VirtualServerSpecRoutesActionProxyRequestHeaders
 */
export interface VirtualServerSpecRoutesActionProxyRequestHeaders {
  /**
   * @schema VirtualServerSpecRoutesActionProxyRequestHeaders#pass
   */
  readonly pass?: boolean;

  /**
   * @schema VirtualServerSpecRoutesActionProxyRequestHeaders#set
   */
  readonly set?: VirtualServerSpecRoutesActionProxyRequestHeadersSet[];

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesActionProxyRequestHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesActionProxyRequestHeaders(obj: VirtualServerSpecRoutesActionProxyRequestHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pass': obj.pass,
    'set': obj.set?.map(y => toJson_VirtualServerSpecRoutesActionProxyRequestHeadersSet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProxyResponseHeaders defines the response headers manipulation in an ActionProxy.
 *
 * @schema VirtualServerSpecRoutesActionProxyResponseHeaders
 */
export interface VirtualServerSpecRoutesActionProxyResponseHeaders {
  /**
   * @schema VirtualServerSpecRoutesActionProxyResponseHeaders#add
   */
  readonly add?: VirtualServerSpecRoutesActionProxyResponseHeadersAdd[];

  /**
   * @schema VirtualServerSpecRoutesActionProxyResponseHeaders#hide
   */
  readonly hide?: string[];

  /**
   * @schema VirtualServerSpecRoutesActionProxyResponseHeaders#ignore
   */
  readonly ignore?: string[];

  /**
   * @schema VirtualServerSpecRoutesActionProxyResponseHeaders#pass
   */
  readonly pass?: string[];

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesActionProxyResponseHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesActionProxyResponseHeaders(obj: VirtualServerSpecRoutesActionProxyResponseHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => toJson_VirtualServerSpecRoutesActionProxyResponseHeadersAdd(y)),
    'hide': obj.hide?.map(y => y),
    'ignore': obj.ignore?.map(y => y),
    'pass': obj.pass?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Header defines an HTTP Header.
 *
 * @schema VirtualServerSpecRoutesErrorPagesReturnHeaders
 */
export interface VirtualServerSpecRoutesErrorPagesReturnHeaders {
  /**
   * @schema VirtualServerSpecRoutesErrorPagesReturnHeaders#name
   */
  readonly name?: string;

  /**
   * @schema VirtualServerSpecRoutesErrorPagesReturnHeaders#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesErrorPagesReturnHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesErrorPagesReturnHeaders(obj: VirtualServerSpecRoutesErrorPagesReturnHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ActionProxy defines a proxy in an Action.
 *
 * @schema VirtualServerSpecRoutesMatchesActionProxy
 */
export interface VirtualServerSpecRoutesMatchesActionProxy {
  /**
   * ProxyRequestHeaders defines the request headers manipulation in an ActionProxy.
   *
   * @schema VirtualServerSpecRoutesMatchesActionProxy#requestHeaders
   */
  readonly requestHeaders?: VirtualServerSpecRoutesMatchesActionProxyRequestHeaders;

  /**
   * ProxyResponseHeaders defines the response headers manipulation in an ActionProxy.
   *
   * @schema VirtualServerSpecRoutesMatchesActionProxy#responseHeaders
   */
  readonly responseHeaders?: VirtualServerSpecRoutesMatchesActionProxyResponseHeaders;

  /**
   * @schema VirtualServerSpecRoutesMatchesActionProxy#rewritePath
   */
  readonly rewritePath?: string;

  /**
   * @schema VirtualServerSpecRoutesMatchesActionProxy#upstream
   */
  readonly upstream?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesMatchesActionProxy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesMatchesActionProxy(obj: VirtualServerSpecRoutesMatchesActionProxy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'requestHeaders': toJson_VirtualServerSpecRoutesMatchesActionProxyRequestHeaders(obj.requestHeaders),
    'responseHeaders': toJson_VirtualServerSpecRoutesMatchesActionProxyResponseHeaders(obj.responseHeaders),
    'rewritePath': obj.rewritePath,
    'upstream': obj.upstream,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ActionRedirect defines a redirect in an Action.
 *
 * @schema VirtualServerSpecRoutesMatchesActionRedirect
 */
export interface VirtualServerSpecRoutesMatchesActionRedirect {
  /**
   * @schema VirtualServerSpecRoutesMatchesActionRedirect#code
   */
  readonly code?: number;

  /**
   * @schema VirtualServerSpecRoutesMatchesActionRedirect#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesMatchesActionRedirect' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesMatchesActionRedirect(obj: VirtualServerSpecRoutesMatchesActionRedirect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'code': obj.code,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ActionReturn defines a return in an Action.
 *
 * @schema VirtualServerSpecRoutesMatchesActionReturn
 */
export interface VirtualServerSpecRoutesMatchesActionReturn {
  /**
   * @schema VirtualServerSpecRoutesMatchesActionReturn#body
   */
  readonly body?: string;

  /**
   * @schema VirtualServerSpecRoutesMatchesActionReturn#code
   */
  readonly code?: number;

  /**
   * @schema VirtualServerSpecRoutesMatchesActionReturn#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesMatchesActionReturn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesMatchesActionReturn(obj: VirtualServerSpecRoutesMatchesActionReturn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'body': obj.body,
    'code': obj.code,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Action defines an action.
 *
 * @schema VirtualServerSpecRoutesMatchesSplitsAction
 */
export interface VirtualServerSpecRoutesMatchesSplitsAction {
  /**
   * @schema VirtualServerSpecRoutesMatchesSplitsAction#pass
   */
  readonly pass?: string;

  /**
   * ActionProxy defines a proxy in an Action.
   *
   * @schema VirtualServerSpecRoutesMatchesSplitsAction#proxy
   */
  readonly proxy?: VirtualServerSpecRoutesMatchesSplitsActionProxy;

  /**
   * ActionRedirect defines a redirect in an Action.
   *
   * @schema VirtualServerSpecRoutesMatchesSplitsAction#redirect
   */
  readonly redirect?: VirtualServerSpecRoutesMatchesSplitsActionRedirect;

  /**
   * ActionReturn defines a return in an Action.
   *
   * @schema VirtualServerSpecRoutesMatchesSplitsAction#return
   */
  readonly return?: VirtualServerSpecRoutesMatchesSplitsActionReturn;

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesMatchesSplitsAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesMatchesSplitsAction(obj: VirtualServerSpecRoutesMatchesSplitsAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pass': obj.pass,
    'proxy': toJson_VirtualServerSpecRoutesMatchesSplitsActionProxy(obj.proxy),
    'redirect': toJson_VirtualServerSpecRoutesMatchesSplitsActionRedirect(obj.redirect),
    'return': toJson_VirtualServerSpecRoutesMatchesSplitsActionReturn(obj.return),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ActionProxy defines a proxy in an Action.
 *
 * @schema VirtualServerSpecRoutesSplitsActionProxy
 */
export interface VirtualServerSpecRoutesSplitsActionProxy {
  /**
   * ProxyRequestHeaders defines the request headers manipulation in an ActionProxy.
   *
   * @schema VirtualServerSpecRoutesSplitsActionProxy#requestHeaders
   */
  readonly requestHeaders?: VirtualServerSpecRoutesSplitsActionProxyRequestHeaders;

  /**
   * ProxyResponseHeaders defines the response headers manipulation in an ActionProxy.
   *
   * @schema VirtualServerSpecRoutesSplitsActionProxy#responseHeaders
   */
  readonly responseHeaders?: VirtualServerSpecRoutesSplitsActionProxyResponseHeaders;

  /**
   * @schema VirtualServerSpecRoutesSplitsActionProxy#rewritePath
   */
  readonly rewritePath?: string;

  /**
   * @schema VirtualServerSpecRoutesSplitsActionProxy#upstream
   */
  readonly upstream?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesSplitsActionProxy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesSplitsActionProxy(obj: VirtualServerSpecRoutesSplitsActionProxy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'requestHeaders': toJson_VirtualServerSpecRoutesSplitsActionProxyRequestHeaders(obj.requestHeaders),
    'responseHeaders': toJson_VirtualServerSpecRoutesSplitsActionProxyResponseHeaders(obj.responseHeaders),
    'rewritePath': obj.rewritePath,
    'upstream': obj.upstream,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ActionRedirect defines a redirect in an Action.
 *
 * @schema VirtualServerSpecRoutesSplitsActionRedirect
 */
export interface VirtualServerSpecRoutesSplitsActionRedirect {
  /**
   * @schema VirtualServerSpecRoutesSplitsActionRedirect#code
   */
  readonly code?: number;

  /**
   * @schema VirtualServerSpecRoutesSplitsActionRedirect#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesSplitsActionRedirect' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesSplitsActionRedirect(obj: VirtualServerSpecRoutesSplitsActionRedirect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'code': obj.code,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ActionReturn defines a return in an Action.
 *
 * @schema VirtualServerSpecRoutesSplitsActionReturn
 */
export interface VirtualServerSpecRoutesSplitsActionReturn {
  /**
   * @schema VirtualServerSpecRoutesSplitsActionReturn#body
   */
  readonly body?: string;

  /**
   * @schema VirtualServerSpecRoutesSplitsActionReturn#code
   */
  readonly code?: number;

  /**
   * @schema VirtualServerSpecRoutesSplitsActionReturn#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesSplitsActionReturn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesSplitsActionReturn(obj: VirtualServerSpecRoutesSplitsActionReturn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'body': obj.body,
    'code': obj.code,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Header defines an HTTP Header.
 *
 * @schema VirtualServerSpecRoutesActionProxyRequestHeadersSet
 */
export interface VirtualServerSpecRoutesActionProxyRequestHeadersSet {
  /**
   * @schema VirtualServerSpecRoutesActionProxyRequestHeadersSet#name
   */
  readonly name?: string;

  /**
   * @schema VirtualServerSpecRoutesActionProxyRequestHeadersSet#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesActionProxyRequestHeadersSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesActionProxyRequestHeadersSet(obj: VirtualServerSpecRoutesActionProxyRequestHeadersSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AddHeader defines an HTTP Header with an optional Always field to use with the add_header NGINX directive.
 *
 * @schema VirtualServerSpecRoutesActionProxyResponseHeadersAdd
 */
export interface VirtualServerSpecRoutesActionProxyResponseHeadersAdd {
  /**
   * @schema VirtualServerSpecRoutesActionProxyResponseHeadersAdd#always
   */
  readonly always?: boolean;

  /**
   * @schema VirtualServerSpecRoutesActionProxyResponseHeadersAdd#name
   */
  readonly name?: string;

  /**
   * @schema VirtualServerSpecRoutesActionProxyResponseHeadersAdd#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesActionProxyResponseHeadersAdd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesActionProxyResponseHeadersAdd(obj: VirtualServerSpecRoutesActionProxyResponseHeadersAdd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'always': obj.always,
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProxyRequestHeaders defines the request headers manipulation in an ActionProxy.
 *
 * @schema VirtualServerSpecRoutesMatchesActionProxyRequestHeaders
 */
export interface VirtualServerSpecRoutesMatchesActionProxyRequestHeaders {
  /**
   * @schema VirtualServerSpecRoutesMatchesActionProxyRequestHeaders#pass
   */
  readonly pass?: boolean;

  /**
   * @schema VirtualServerSpecRoutesMatchesActionProxyRequestHeaders#set
   */
  readonly set?: VirtualServerSpecRoutesMatchesActionProxyRequestHeadersSet[];

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesMatchesActionProxyRequestHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesMatchesActionProxyRequestHeaders(obj: VirtualServerSpecRoutesMatchesActionProxyRequestHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pass': obj.pass,
    'set': obj.set?.map(y => toJson_VirtualServerSpecRoutesMatchesActionProxyRequestHeadersSet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProxyResponseHeaders defines the response headers manipulation in an ActionProxy.
 *
 * @schema VirtualServerSpecRoutesMatchesActionProxyResponseHeaders
 */
export interface VirtualServerSpecRoutesMatchesActionProxyResponseHeaders {
  /**
   * @schema VirtualServerSpecRoutesMatchesActionProxyResponseHeaders#add
   */
  readonly add?: VirtualServerSpecRoutesMatchesActionProxyResponseHeadersAdd[];

  /**
   * @schema VirtualServerSpecRoutesMatchesActionProxyResponseHeaders#hide
   */
  readonly hide?: string[];

  /**
   * @schema VirtualServerSpecRoutesMatchesActionProxyResponseHeaders#ignore
   */
  readonly ignore?: string[];

  /**
   * @schema VirtualServerSpecRoutesMatchesActionProxyResponseHeaders#pass
   */
  readonly pass?: string[];

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesMatchesActionProxyResponseHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesMatchesActionProxyResponseHeaders(obj: VirtualServerSpecRoutesMatchesActionProxyResponseHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => toJson_VirtualServerSpecRoutesMatchesActionProxyResponseHeadersAdd(y)),
    'hide': obj.hide?.map(y => y),
    'ignore': obj.ignore?.map(y => y),
    'pass': obj.pass?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ActionProxy defines a proxy in an Action.
 *
 * @schema VirtualServerSpecRoutesMatchesSplitsActionProxy
 */
export interface VirtualServerSpecRoutesMatchesSplitsActionProxy {
  /**
   * ProxyRequestHeaders defines the request headers manipulation in an ActionProxy.
   *
   * @schema VirtualServerSpecRoutesMatchesSplitsActionProxy#requestHeaders
   */
  readonly requestHeaders?: VirtualServerSpecRoutesMatchesSplitsActionProxyRequestHeaders;

  /**
   * ProxyResponseHeaders defines the response headers manipulation in an ActionProxy.
   *
   * @schema VirtualServerSpecRoutesMatchesSplitsActionProxy#responseHeaders
   */
  readonly responseHeaders?: VirtualServerSpecRoutesMatchesSplitsActionProxyResponseHeaders;

  /**
   * @schema VirtualServerSpecRoutesMatchesSplitsActionProxy#rewritePath
   */
  readonly rewritePath?: string;

  /**
   * @schema VirtualServerSpecRoutesMatchesSplitsActionProxy#upstream
   */
  readonly upstream?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesMatchesSplitsActionProxy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesMatchesSplitsActionProxy(obj: VirtualServerSpecRoutesMatchesSplitsActionProxy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'requestHeaders': toJson_VirtualServerSpecRoutesMatchesSplitsActionProxyRequestHeaders(obj.requestHeaders),
    'responseHeaders': toJson_VirtualServerSpecRoutesMatchesSplitsActionProxyResponseHeaders(obj.responseHeaders),
    'rewritePath': obj.rewritePath,
    'upstream': obj.upstream,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ActionRedirect defines a redirect in an Action.
 *
 * @schema VirtualServerSpecRoutesMatchesSplitsActionRedirect
 */
export interface VirtualServerSpecRoutesMatchesSplitsActionRedirect {
  /**
   * @schema VirtualServerSpecRoutesMatchesSplitsActionRedirect#code
   */
  readonly code?: number;

  /**
   * @schema VirtualServerSpecRoutesMatchesSplitsActionRedirect#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesMatchesSplitsActionRedirect' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesMatchesSplitsActionRedirect(obj: VirtualServerSpecRoutesMatchesSplitsActionRedirect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'code': obj.code,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ActionReturn defines a return in an Action.
 *
 * @schema VirtualServerSpecRoutesMatchesSplitsActionReturn
 */
export interface VirtualServerSpecRoutesMatchesSplitsActionReturn {
  /**
   * @schema VirtualServerSpecRoutesMatchesSplitsActionReturn#body
   */
  readonly body?: string;

  /**
   * @schema VirtualServerSpecRoutesMatchesSplitsActionReturn#code
   */
  readonly code?: number;

  /**
   * @schema VirtualServerSpecRoutesMatchesSplitsActionReturn#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesMatchesSplitsActionReturn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesMatchesSplitsActionReturn(obj: VirtualServerSpecRoutesMatchesSplitsActionReturn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'body': obj.body,
    'code': obj.code,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProxyRequestHeaders defines the request headers manipulation in an ActionProxy.
 *
 * @schema VirtualServerSpecRoutesSplitsActionProxyRequestHeaders
 */
export interface VirtualServerSpecRoutesSplitsActionProxyRequestHeaders {
  /**
   * @schema VirtualServerSpecRoutesSplitsActionProxyRequestHeaders#pass
   */
  readonly pass?: boolean;

  /**
   * @schema VirtualServerSpecRoutesSplitsActionProxyRequestHeaders#set
   */
  readonly set?: VirtualServerSpecRoutesSplitsActionProxyRequestHeadersSet[];

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesSplitsActionProxyRequestHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesSplitsActionProxyRequestHeaders(obj: VirtualServerSpecRoutesSplitsActionProxyRequestHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pass': obj.pass,
    'set': obj.set?.map(y => toJson_VirtualServerSpecRoutesSplitsActionProxyRequestHeadersSet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProxyResponseHeaders defines the response headers manipulation in an ActionProxy.
 *
 * @schema VirtualServerSpecRoutesSplitsActionProxyResponseHeaders
 */
export interface VirtualServerSpecRoutesSplitsActionProxyResponseHeaders {
  /**
   * @schema VirtualServerSpecRoutesSplitsActionProxyResponseHeaders#add
   */
  readonly add?: VirtualServerSpecRoutesSplitsActionProxyResponseHeadersAdd[];

  /**
   * @schema VirtualServerSpecRoutesSplitsActionProxyResponseHeaders#hide
   */
  readonly hide?: string[];

  /**
   * @schema VirtualServerSpecRoutesSplitsActionProxyResponseHeaders#ignore
   */
  readonly ignore?: string[];

  /**
   * @schema VirtualServerSpecRoutesSplitsActionProxyResponseHeaders#pass
   */
  readonly pass?: string[];

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesSplitsActionProxyResponseHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesSplitsActionProxyResponseHeaders(obj: VirtualServerSpecRoutesSplitsActionProxyResponseHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => toJson_VirtualServerSpecRoutesSplitsActionProxyResponseHeadersAdd(y)),
    'hide': obj.hide?.map(y => y),
    'ignore': obj.ignore?.map(y => y),
    'pass': obj.pass?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Header defines an HTTP Header.
 *
 * @schema VirtualServerSpecRoutesMatchesActionProxyRequestHeadersSet
 */
export interface VirtualServerSpecRoutesMatchesActionProxyRequestHeadersSet {
  /**
   * @schema VirtualServerSpecRoutesMatchesActionProxyRequestHeadersSet#name
   */
  readonly name?: string;

  /**
   * @schema VirtualServerSpecRoutesMatchesActionProxyRequestHeadersSet#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesMatchesActionProxyRequestHeadersSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesMatchesActionProxyRequestHeadersSet(obj: VirtualServerSpecRoutesMatchesActionProxyRequestHeadersSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AddHeader defines an HTTP Header with an optional Always field to use with the add_header NGINX directive.
 *
 * @schema VirtualServerSpecRoutesMatchesActionProxyResponseHeadersAdd
 */
export interface VirtualServerSpecRoutesMatchesActionProxyResponseHeadersAdd {
  /**
   * @schema VirtualServerSpecRoutesMatchesActionProxyResponseHeadersAdd#always
   */
  readonly always?: boolean;

  /**
   * @schema VirtualServerSpecRoutesMatchesActionProxyResponseHeadersAdd#name
   */
  readonly name?: string;

  /**
   * @schema VirtualServerSpecRoutesMatchesActionProxyResponseHeadersAdd#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesMatchesActionProxyResponseHeadersAdd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesMatchesActionProxyResponseHeadersAdd(obj: VirtualServerSpecRoutesMatchesActionProxyResponseHeadersAdd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'always': obj.always,
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProxyRequestHeaders defines the request headers manipulation in an ActionProxy.
 *
 * @schema VirtualServerSpecRoutesMatchesSplitsActionProxyRequestHeaders
 */
export interface VirtualServerSpecRoutesMatchesSplitsActionProxyRequestHeaders {
  /**
   * @schema VirtualServerSpecRoutesMatchesSplitsActionProxyRequestHeaders#pass
   */
  readonly pass?: boolean;

  /**
   * @schema VirtualServerSpecRoutesMatchesSplitsActionProxyRequestHeaders#set
   */
  readonly set?: VirtualServerSpecRoutesMatchesSplitsActionProxyRequestHeadersSet[];

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesMatchesSplitsActionProxyRequestHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesMatchesSplitsActionProxyRequestHeaders(obj: VirtualServerSpecRoutesMatchesSplitsActionProxyRequestHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pass': obj.pass,
    'set': obj.set?.map(y => toJson_VirtualServerSpecRoutesMatchesSplitsActionProxyRequestHeadersSet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProxyResponseHeaders defines the response headers manipulation in an ActionProxy.
 *
 * @schema VirtualServerSpecRoutesMatchesSplitsActionProxyResponseHeaders
 */
export interface VirtualServerSpecRoutesMatchesSplitsActionProxyResponseHeaders {
  /**
   * @schema VirtualServerSpecRoutesMatchesSplitsActionProxyResponseHeaders#add
   */
  readonly add?: VirtualServerSpecRoutesMatchesSplitsActionProxyResponseHeadersAdd[];

  /**
   * @schema VirtualServerSpecRoutesMatchesSplitsActionProxyResponseHeaders#hide
   */
  readonly hide?: string[];

  /**
   * @schema VirtualServerSpecRoutesMatchesSplitsActionProxyResponseHeaders#ignore
   */
  readonly ignore?: string[];

  /**
   * @schema VirtualServerSpecRoutesMatchesSplitsActionProxyResponseHeaders#pass
   */
  readonly pass?: string[];

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesMatchesSplitsActionProxyResponseHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesMatchesSplitsActionProxyResponseHeaders(obj: VirtualServerSpecRoutesMatchesSplitsActionProxyResponseHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => toJson_VirtualServerSpecRoutesMatchesSplitsActionProxyResponseHeadersAdd(y)),
    'hide': obj.hide?.map(y => y),
    'ignore': obj.ignore?.map(y => y),
    'pass': obj.pass?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Header defines an HTTP Header.
 *
 * @schema VirtualServerSpecRoutesSplitsActionProxyRequestHeadersSet
 */
export interface VirtualServerSpecRoutesSplitsActionProxyRequestHeadersSet {
  /**
   * @schema VirtualServerSpecRoutesSplitsActionProxyRequestHeadersSet#name
   */
  readonly name?: string;

  /**
   * @schema VirtualServerSpecRoutesSplitsActionProxyRequestHeadersSet#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesSplitsActionProxyRequestHeadersSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesSplitsActionProxyRequestHeadersSet(obj: VirtualServerSpecRoutesSplitsActionProxyRequestHeadersSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AddHeader defines an HTTP Header with an optional Always field to use with the add_header NGINX directive.
 *
 * @schema VirtualServerSpecRoutesSplitsActionProxyResponseHeadersAdd
 */
export interface VirtualServerSpecRoutesSplitsActionProxyResponseHeadersAdd {
  /**
   * @schema VirtualServerSpecRoutesSplitsActionProxyResponseHeadersAdd#always
   */
  readonly always?: boolean;

  /**
   * @schema VirtualServerSpecRoutesSplitsActionProxyResponseHeadersAdd#name
   */
  readonly name?: string;

  /**
   * @schema VirtualServerSpecRoutesSplitsActionProxyResponseHeadersAdd#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesSplitsActionProxyResponseHeadersAdd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesSplitsActionProxyResponseHeadersAdd(obj: VirtualServerSpecRoutesSplitsActionProxyResponseHeadersAdd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'always': obj.always,
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Header defines an HTTP Header.
 *
 * @schema VirtualServerSpecRoutesMatchesSplitsActionProxyRequestHeadersSet
 */
export interface VirtualServerSpecRoutesMatchesSplitsActionProxyRequestHeadersSet {
  /**
   * @schema VirtualServerSpecRoutesMatchesSplitsActionProxyRequestHeadersSet#name
   */
  readonly name?: string;

  /**
   * @schema VirtualServerSpecRoutesMatchesSplitsActionProxyRequestHeadersSet#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesMatchesSplitsActionProxyRequestHeadersSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesMatchesSplitsActionProxyRequestHeadersSet(obj: VirtualServerSpecRoutesMatchesSplitsActionProxyRequestHeadersSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AddHeader defines an HTTP Header with an optional Always field to use with the add_header NGINX directive.
 *
 * @schema VirtualServerSpecRoutesMatchesSplitsActionProxyResponseHeadersAdd
 */
export interface VirtualServerSpecRoutesMatchesSplitsActionProxyResponseHeadersAdd {
  /**
   * @schema VirtualServerSpecRoutesMatchesSplitsActionProxyResponseHeadersAdd#always
   */
  readonly always?: boolean;

  /**
   * @schema VirtualServerSpecRoutesMatchesSplitsActionProxyResponseHeadersAdd#name
   */
  readonly name?: string;

  /**
   * @schema VirtualServerSpecRoutesMatchesSplitsActionProxyResponseHeadersAdd#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VirtualServerSpecRoutesMatchesSplitsActionProxyResponseHeadersAdd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerSpecRoutesMatchesSplitsActionProxyResponseHeadersAdd(obj: VirtualServerSpecRoutesMatchesSplitsActionProxyResponseHeadersAdd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'always': obj.always,
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */


/**
 * VirtualServerRoute defines the VirtualServerRoute resource.
 *
 * @schema VirtualServerRoute
 */
export class VirtualServerRoute extends ApiObject {
  /**
   * Returns the apiVersion and kind for "VirtualServerRoute"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'k8s.nginx.org/v1',
    kind: 'VirtualServerRoute',
  }

  /**
   * Renders a Kubernetes manifest for "VirtualServerRoute".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: VirtualServerRouteProps = {}): any {
    return {
      ...VirtualServerRoute.GVK,
      ...toJson_VirtualServerRouteProps(props),
    };
  }

  /**
   * Defines a "VirtualServerRoute" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: VirtualServerRouteProps = {}) {
    super(scope, id, {
      ...VirtualServerRoute.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...VirtualServerRoute.GVK,
      ...toJson_VirtualServerRouteProps(resolved),
    };
  }
}

/**
 * VirtualServerRoute defines the VirtualServerRoute resource.
 *
 * @schema VirtualServerRoute
 */
export interface VirtualServerRouteProps {
  /**
   * @schema VirtualServerRoute#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * VirtualServerRouteSpec is the spec of the VirtualServerRoute resource.
   *
   * @schema VirtualServerRoute#spec
   */
  readonly spec?: VirtualServerRouteSpec;

}

/**
 * Converts an object of type 'VirtualServerRouteProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteProps(obj: VirtualServerRouteProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_VirtualServerRouteSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * VirtualServerRouteSpec is the spec of the VirtualServerRoute resource.
 *
 * @schema VirtualServerRouteSpec
 */
export interface VirtualServerRouteSpec {
  /**
   * @schema VirtualServerRouteSpec#host
   */
  readonly host?: string;

  /**
   * @schema VirtualServerRouteSpec#ingressClassName
   */
  readonly ingressClassName?: string;

  /**
   * @schema VirtualServerRouteSpec#subroutes
   */
  readonly subroutes?: VirtualServerRouteSpecSubroutes[];

  /**
   * @schema VirtualServerRouteSpec#upstreams
   */
  readonly upstreams?: VirtualServerRouteSpecUpstreams[];

}

/**
 * Converts an object of type 'VirtualServerRouteSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpec(obj: VirtualServerRouteSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'ingressClassName': obj.ingressClassName,
    'subroutes': obj.subroutes?.map(y => toJson_VirtualServerRouteSpecSubroutes(y)),
    'upstreams': obj.upstreams?.map(y => toJson_VirtualServerRouteSpecUpstreams(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Route defines a route.
 *
 * @schema VirtualServerRouteSpecSubroutes
 */
export interface VirtualServerRouteSpecSubroutes {
  /**
   * Action defines an action.
   *
   * @schema VirtualServerRouteSpecSubroutes#action
   */
  readonly action?: VirtualServerRouteSpecSubroutesAction;

  /**
   * @schema VirtualServerRouteSpecSubroutes#dos
   */
  readonly dos?: string;

  /**
   * @schema VirtualServerRouteSpecSubroutes#errorPages
   */
  readonly errorPages?: VirtualServerRouteSpecSubroutesErrorPages[];

  /**
   * @schema VirtualServerRouteSpecSubroutes#location-snippets
   */
  readonly locationSnippets?: string;

  /**
   * @schema VirtualServerRouteSpecSubroutes#matches
   */
  readonly matches?: VirtualServerRouteSpecSubroutesMatches[];

  /**
   * @schema VirtualServerRouteSpecSubroutes#path
   */
  readonly path?: string;

  /**
   * @schema VirtualServerRouteSpecSubroutes#policies
   */
  readonly policies?: VirtualServerRouteSpecSubroutesPolicies[];

  /**
   * @schema VirtualServerRouteSpecSubroutes#route
   */
  readonly route?: string;

  /**
   * @schema VirtualServerRouteSpecSubroutes#splits
   */
  readonly splits?: VirtualServerRouteSpecSubroutesSplits[];

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutes' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutes(obj: VirtualServerRouteSpecSubroutes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': toJson_VirtualServerRouteSpecSubroutesAction(obj.action),
    'dos': obj.dos,
    'errorPages': obj.errorPages?.map(y => toJson_VirtualServerRouteSpecSubroutesErrorPages(y)),
    'location-snippets': obj.locationSnippets,
    'matches': obj.matches?.map(y => toJson_VirtualServerRouteSpecSubroutesMatches(y)),
    'path': obj.path,
    'policies': obj.policies?.map(y => toJson_VirtualServerRouteSpecSubroutesPolicies(y)),
    'route': obj.route,
    'splits': obj.splits?.map(y => toJson_VirtualServerRouteSpecSubroutesSplits(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Upstream defines an upstream.
 *
 * @schema VirtualServerRouteSpecUpstreams
 */
export interface VirtualServerRouteSpecUpstreams {
  /**
   * @schema VirtualServerRouteSpecUpstreams#buffer-size
   */
  readonly bufferSize?: string;

  /**
   * @schema VirtualServerRouteSpecUpstreams#buffering
   */
  readonly buffering?: boolean;

  /**
   * UpstreamBuffers defines Buffer Configuration for an Upstream.
   *
   * @schema VirtualServerRouteSpecUpstreams#buffers
   */
  readonly buffers?: VirtualServerRouteSpecUpstreamsBuffers;

  /**
   * @schema VirtualServerRouteSpecUpstreams#client-max-body-size
   */
  readonly clientMaxBodySize?: string;

  /**
   * @schema VirtualServerRouteSpecUpstreams#connect-timeout
   */
  readonly connectTimeout?: string;

  /**
   * @schema VirtualServerRouteSpecUpstreams#fail-timeout
   */
  readonly failTimeout?: string;

  /**
   * HealthCheck defines the parameters for active Upstream HealthChecks.
   *
   * @schema VirtualServerRouteSpecUpstreams#healthCheck
   */
  readonly healthCheck?: VirtualServerRouteSpecUpstreamsHealthCheck;

  /**
   * @schema VirtualServerRouteSpecUpstreams#keepalive
   */
  readonly keepalive?: number;

  /**
   * @schema VirtualServerRouteSpecUpstreams#lb-method
   */
  readonly lbMethod?: string;

  /**
   * @schema VirtualServerRouteSpecUpstreams#max-conns
   */
  readonly maxConns?: number;

  /**
   * @schema VirtualServerRouteSpecUpstreams#max-fails
   */
  readonly maxFails?: number;

  /**
   * @schema VirtualServerRouteSpecUpstreams#name
   */
  readonly name?: string;

  /**
   * @schema VirtualServerRouteSpecUpstreams#next-upstream
   */
  readonly nextUpstream?: string;

  /**
   * @schema VirtualServerRouteSpecUpstreams#next-upstream-timeout
   */
  readonly nextUpstreamTimeout?: string;

  /**
   * @schema VirtualServerRouteSpecUpstreams#next-upstream-tries
   */
  readonly nextUpstreamTries?: number;

  /**
   * @schema VirtualServerRouteSpecUpstreams#ntlm
   */
  readonly ntlm?: boolean;

  /**
   * @schema VirtualServerRouteSpecUpstreams#port
   */
  readonly port?: number;

  /**
   * UpstreamQueue defines Queue Configuration for an Upstream.
   *
   * @schema VirtualServerRouteSpecUpstreams#queue
   */
  readonly queue?: VirtualServerRouteSpecUpstreamsQueue;

  /**
   * @schema VirtualServerRouteSpecUpstreams#read-timeout
   */
  readonly readTimeout?: string;

  /**
   * @schema VirtualServerRouteSpecUpstreams#send-timeout
   */
  readonly sendTimeout?: string;

  /**
   * @schema VirtualServerRouteSpecUpstreams#service
   */
  readonly service?: string;

  /**
   * SessionCookie defines the parameters for session persistence.
   *
   * @schema VirtualServerRouteSpecUpstreams#sessionCookie
   */
  readonly sessionCookie?: VirtualServerRouteSpecUpstreamsSessionCookie;

  /**
   * @schema VirtualServerRouteSpecUpstreams#slow-start
   */
  readonly slowStart?: string;

  /**
   * @schema VirtualServerRouteSpecUpstreams#subselector
   */
  readonly subselector?: { [key: string]: string };

  /**
   * UpstreamTLS defines a TLS configuration for an Upstream.
   *
   * @schema VirtualServerRouteSpecUpstreams#tls
   */
  readonly tls?: VirtualServerRouteSpecUpstreamsTls;

  /**
   * @schema VirtualServerRouteSpecUpstreams#type
   */
  readonly type?: string;

  /**
   * @schema VirtualServerRouteSpecUpstreams#use-cluster-ip
   */
  readonly useClusterIp?: boolean;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecUpstreams' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecUpstreams(obj: VirtualServerRouteSpecUpstreams | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'buffer-size': obj.bufferSize,
    'buffering': obj.buffering,
    'buffers': toJson_VirtualServerRouteSpecUpstreamsBuffers(obj.buffers),
    'client-max-body-size': obj.clientMaxBodySize,
    'connect-timeout': obj.connectTimeout,
    'fail-timeout': obj.failTimeout,
    'healthCheck': toJson_VirtualServerRouteSpecUpstreamsHealthCheck(obj.healthCheck),
    'keepalive': obj.keepalive,
    'lb-method': obj.lbMethod,
    'max-conns': obj.maxConns,
    'max-fails': obj.maxFails,
    'name': obj.name,
    'next-upstream': obj.nextUpstream,
    'next-upstream-timeout': obj.nextUpstreamTimeout,
    'next-upstream-tries': obj.nextUpstreamTries,
    'ntlm': obj.ntlm,
    'port': obj.port,
    'queue': toJson_VirtualServerRouteSpecUpstreamsQueue(obj.queue),
    'read-timeout': obj.readTimeout,
    'send-timeout': obj.sendTimeout,
    'service': obj.service,
    'sessionCookie': toJson_VirtualServerRouteSpecUpstreamsSessionCookie(obj.sessionCookie),
    'slow-start': obj.slowStart,
    'subselector': ((obj.subselector) === undefined) ? undefined : (Object.entries(obj.subselector).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'tls': toJson_VirtualServerRouteSpecUpstreamsTls(obj.tls),
    'type': obj.type,
    'use-cluster-ip': obj.useClusterIp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Action defines an action.
 *
 * @schema VirtualServerRouteSpecSubroutesAction
 */
export interface VirtualServerRouteSpecSubroutesAction {
  /**
   * @schema VirtualServerRouteSpecSubroutesAction#pass
   */
  readonly pass?: string;

  /**
   * ActionProxy defines a proxy in an Action.
   *
   * @schema VirtualServerRouteSpecSubroutesAction#proxy
   */
  readonly proxy?: VirtualServerRouteSpecSubroutesActionProxy;

  /**
   * ActionRedirect defines a redirect in an Action.
   *
   * @schema VirtualServerRouteSpecSubroutesAction#redirect
   */
  readonly redirect?: VirtualServerRouteSpecSubroutesActionRedirect;

  /**
   * ActionReturn defines a return in an Action.
   *
   * @schema VirtualServerRouteSpecSubroutesAction#return
   */
  readonly return?: VirtualServerRouteSpecSubroutesActionReturn;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesAction(obj: VirtualServerRouteSpecSubroutesAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pass': obj.pass,
    'proxy': toJson_VirtualServerRouteSpecSubroutesActionProxy(obj.proxy),
    'redirect': toJson_VirtualServerRouteSpecSubroutesActionRedirect(obj.redirect),
    'return': toJson_VirtualServerRouteSpecSubroutesActionReturn(obj.return),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ErrorPage defines an ErrorPage in a Route.
 *
 * @schema VirtualServerRouteSpecSubroutesErrorPages
 */
export interface VirtualServerRouteSpecSubroutesErrorPages {
  /**
   * @schema VirtualServerRouteSpecSubroutesErrorPages#codes
   */
  readonly codes?: number[];

  /**
   * ErrorPageRedirect defines a redirect for an ErrorPage.
   *
   * @schema VirtualServerRouteSpecSubroutesErrorPages#redirect
   */
  readonly redirect?: VirtualServerRouteSpecSubroutesErrorPagesRedirect;

  /**
   * ErrorPageReturn defines a return for an ErrorPage.
   *
   * @schema VirtualServerRouteSpecSubroutesErrorPages#return
   */
  readonly return?: VirtualServerRouteSpecSubroutesErrorPagesReturn;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesErrorPages' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesErrorPages(obj: VirtualServerRouteSpecSubroutesErrorPages | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'codes': obj.codes?.map(y => y),
    'redirect': toJson_VirtualServerRouteSpecSubroutesErrorPagesRedirect(obj.redirect),
    'return': toJson_VirtualServerRouteSpecSubroutesErrorPagesReturn(obj.return),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Match defines a match.
 *
 * @schema VirtualServerRouteSpecSubroutesMatches
 */
export interface VirtualServerRouteSpecSubroutesMatches {
  /**
   * Action defines an action.
   *
   * @schema VirtualServerRouteSpecSubroutesMatches#action
   */
  readonly action?: VirtualServerRouteSpecSubroutesMatchesAction;

  /**
   * @schema VirtualServerRouteSpecSubroutesMatches#conditions
   */
  readonly conditions?: VirtualServerRouteSpecSubroutesMatchesConditions[];

  /**
   * @schema VirtualServerRouteSpecSubroutesMatches#splits
   */
  readonly splits?: VirtualServerRouteSpecSubroutesMatchesSplits[];

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesMatches' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesMatches(obj: VirtualServerRouteSpecSubroutesMatches | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': toJson_VirtualServerRouteSpecSubroutesMatchesAction(obj.action),
    'conditions': obj.conditions?.map(y => toJson_VirtualServerRouteSpecSubroutesMatchesConditions(y)),
    'splits': obj.splits?.map(y => toJson_VirtualServerRouteSpecSubroutesMatchesSplits(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PolicyReference references a policy by name and an optional namespace.
 *
 * @schema VirtualServerRouteSpecSubroutesPolicies
 */
export interface VirtualServerRouteSpecSubroutesPolicies {
  /**
   * @schema VirtualServerRouteSpecSubroutesPolicies#name
   */
  readonly name?: string;

  /**
   * @schema VirtualServerRouteSpecSubroutesPolicies#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesPolicies' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesPolicies(obj: VirtualServerRouteSpecSubroutesPolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Split defines a split.
 *
 * @schema VirtualServerRouteSpecSubroutesSplits
 */
export interface VirtualServerRouteSpecSubroutesSplits {
  /**
   * Action defines an action.
   *
   * @schema VirtualServerRouteSpecSubroutesSplits#action
   */
  readonly action?: VirtualServerRouteSpecSubroutesSplitsAction;

  /**
   * @schema VirtualServerRouteSpecSubroutesSplits#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesSplits' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesSplits(obj: VirtualServerRouteSpecSubroutesSplits | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': toJson_VirtualServerRouteSpecSubroutesSplitsAction(obj.action),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UpstreamBuffers defines Buffer Configuration for an Upstream.
 *
 * @schema VirtualServerRouteSpecUpstreamsBuffers
 */
export interface VirtualServerRouteSpecUpstreamsBuffers {
  /**
   * @schema VirtualServerRouteSpecUpstreamsBuffers#number
   */
  readonly number?: number;

  /**
   * @schema VirtualServerRouteSpecUpstreamsBuffers#size
   */
  readonly size?: string;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecUpstreamsBuffers' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecUpstreamsBuffers(obj: VirtualServerRouteSpecUpstreamsBuffers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'number': obj.number,
    'size': obj.size,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * HealthCheck defines the parameters for active Upstream HealthChecks.
 *
 * @schema VirtualServerRouteSpecUpstreamsHealthCheck
 */
export interface VirtualServerRouteSpecUpstreamsHealthCheck {
  /**
   * @schema VirtualServerRouteSpecUpstreamsHealthCheck#connect-timeout
   */
  readonly connectTimeout?: string;

  /**
   * @schema VirtualServerRouteSpecUpstreamsHealthCheck#enable
   */
  readonly enable?: boolean;

  /**
   * @schema VirtualServerRouteSpecUpstreamsHealthCheck#fails
   */
  readonly fails?: number;

  /**
   * @schema VirtualServerRouteSpecUpstreamsHealthCheck#grpcService
   */
  readonly grpcService?: string;

  /**
   * @schema VirtualServerRouteSpecUpstreamsHealthCheck#grpcStatus
   */
  readonly grpcStatus?: number;

  /**
   * @schema VirtualServerRouteSpecUpstreamsHealthCheck#headers
   */
  readonly headers?: VirtualServerRouteSpecUpstreamsHealthCheckHeaders[];

  /**
   * @schema VirtualServerRouteSpecUpstreamsHealthCheck#interval
   */
  readonly interval?: string;

  /**
   * @schema VirtualServerRouteSpecUpstreamsHealthCheck#jitter
   */
  readonly jitter?: string;

  /**
   * @schema VirtualServerRouteSpecUpstreamsHealthCheck#keepalive-time
   */
  readonly keepaliveTime?: string;

  /**
   * @schema VirtualServerRouteSpecUpstreamsHealthCheck#mandatory
   */
  readonly mandatory?: boolean;

  /**
   * @schema VirtualServerRouteSpecUpstreamsHealthCheck#passes
   */
  readonly passes?: number;

  /**
   * @schema VirtualServerRouteSpecUpstreamsHealthCheck#path
   */
  readonly path?: string;

  /**
   * @schema VirtualServerRouteSpecUpstreamsHealthCheck#persistent
   */
  readonly persistent?: boolean;

  /**
   * @schema VirtualServerRouteSpecUpstreamsHealthCheck#port
   */
  readonly port?: number;

  /**
   * @schema VirtualServerRouteSpecUpstreamsHealthCheck#read-timeout
   */
  readonly readTimeout?: string;

  /**
   * @schema VirtualServerRouteSpecUpstreamsHealthCheck#send-timeout
   */
  readonly sendTimeout?: string;

  /**
   * @schema VirtualServerRouteSpecUpstreamsHealthCheck#statusMatch
   */
  readonly statusMatch?: string;

  /**
   * UpstreamTLS defines a TLS configuration for an Upstream.
   *
   * @schema VirtualServerRouteSpecUpstreamsHealthCheck#tls
   */
  readonly tls?: VirtualServerRouteSpecUpstreamsHealthCheckTls;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecUpstreamsHealthCheck' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecUpstreamsHealthCheck(obj: VirtualServerRouteSpecUpstreamsHealthCheck | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connect-timeout': obj.connectTimeout,
    'enable': obj.enable,
    'fails': obj.fails,
    'grpcService': obj.grpcService,
    'grpcStatus': obj.grpcStatus,
    'headers': obj.headers?.map(y => toJson_VirtualServerRouteSpecUpstreamsHealthCheckHeaders(y)),
    'interval': obj.interval,
    'jitter': obj.jitter,
    'keepalive-time': obj.keepaliveTime,
    'mandatory': obj.mandatory,
    'passes': obj.passes,
    'path': obj.path,
    'persistent': obj.persistent,
    'port': obj.port,
    'read-timeout': obj.readTimeout,
    'send-timeout': obj.sendTimeout,
    'statusMatch': obj.statusMatch,
    'tls': toJson_VirtualServerRouteSpecUpstreamsHealthCheckTls(obj.tls),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UpstreamQueue defines Queue Configuration for an Upstream.
 *
 * @schema VirtualServerRouteSpecUpstreamsQueue
 */
export interface VirtualServerRouteSpecUpstreamsQueue {
  /**
   * @schema VirtualServerRouteSpecUpstreamsQueue#size
   */
  readonly size?: number;

  /**
   * @schema VirtualServerRouteSpecUpstreamsQueue#timeout
   */
  readonly timeout?: string;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecUpstreamsQueue' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecUpstreamsQueue(obj: VirtualServerRouteSpecUpstreamsQueue | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'size': obj.size,
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * SessionCookie defines the parameters for session persistence.
 *
 * @schema VirtualServerRouteSpecUpstreamsSessionCookie
 */
export interface VirtualServerRouteSpecUpstreamsSessionCookie {
  /**
   * @schema VirtualServerRouteSpecUpstreamsSessionCookie#domain
   */
  readonly domain?: string;

  /**
   * @schema VirtualServerRouteSpecUpstreamsSessionCookie#enable
   */
  readonly enable?: boolean;

  /**
   * @schema VirtualServerRouteSpecUpstreamsSessionCookie#expires
   */
  readonly expires?: string;

  /**
   * @schema VirtualServerRouteSpecUpstreamsSessionCookie#httpOnly
   */
  readonly httpOnly?: boolean;

  /**
   * @schema VirtualServerRouteSpecUpstreamsSessionCookie#name
   */
  readonly name?: string;

  /**
   * @schema VirtualServerRouteSpecUpstreamsSessionCookie#path
   */
  readonly path?: string;

  /**
   * @schema VirtualServerRouteSpecUpstreamsSessionCookie#samesite
   */
  readonly samesite?: string;

  /**
   * @schema VirtualServerRouteSpecUpstreamsSessionCookie#secure
   */
  readonly secure?: boolean;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecUpstreamsSessionCookie' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecUpstreamsSessionCookie(obj: VirtualServerRouteSpecUpstreamsSessionCookie | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'domain': obj.domain,
    'enable': obj.enable,
    'expires': obj.expires,
    'httpOnly': obj.httpOnly,
    'name': obj.name,
    'path': obj.path,
    'samesite': obj.samesite,
    'secure': obj.secure,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UpstreamTLS defines a TLS configuration for an Upstream.
 *
 * @schema VirtualServerRouteSpecUpstreamsTls
 */
export interface VirtualServerRouteSpecUpstreamsTls {
  /**
   * @schema VirtualServerRouteSpecUpstreamsTls#enable
   */
  readonly enable?: boolean;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecUpstreamsTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecUpstreamsTls(obj: VirtualServerRouteSpecUpstreamsTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enable': obj.enable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ActionProxy defines a proxy in an Action.
 *
 * @schema VirtualServerRouteSpecSubroutesActionProxy
 */
export interface VirtualServerRouteSpecSubroutesActionProxy {
  /**
   * ProxyRequestHeaders defines the request headers manipulation in an ActionProxy.
   *
   * @schema VirtualServerRouteSpecSubroutesActionProxy#requestHeaders
   */
  readonly requestHeaders?: VirtualServerRouteSpecSubroutesActionProxyRequestHeaders;

  /**
   * ProxyResponseHeaders defines the response headers manipulation in an ActionProxy.
   *
   * @schema VirtualServerRouteSpecSubroutesActionProxy#responseHeaders
   */
  readonly responseHeaders?: VirtualServerRouteSpecSubroutesActionProxyResponseHeaders;

  /**
   * @schema VirtualServerRouteSpecSubroutesActionProxy#rewritePath
   */
  readonly rewritePath?: string;

  /**
   * @schema VirtualServerRouteSpecSubroutesActionProxy#upstream
   */
  readonly upstream?: string;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesActionProxy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesActionProxy(obj: VirtualServerRouteSpecSubroutesActionProxy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'requestHeaders': toJson_VirtualServerRouteSpecSubroutesActionProxyRequestHeaders(obj.requestHeaders),
    'responseHeaders': toJson_VirtualServerRouteSpecSubroutesActionProxyResponseHeaders(obj.responseHeaders),
    'rewritePath': obj.rewritePath,
    'upstream': obj.upstream,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ActionRedirect defines a redirect in an Action.
 *
 * @schema VirtualServerRouteSpecSubroutesActionRedirect
 */
export interface VirtualServerRouteSpecSubroutesActionRedirect {
  /**
   * @schema VirtualServerRouteSpecSubroutesActionRedirect#code
   */
  readonly code?: number;

  /**
   * @schema VirtualServerRouteSpecSubroutesActionRedirect#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesActionRedirect' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesActionRedirect(obj: VirtualServerRouteSpecSubroutesActionRedirect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'code': obj.code,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ActionReturn defines a return in an Action.
 *
 * @schema VirtualServerRouteSpecSubroutesActionReturn
 */
export interface VirtualServerRouteSpecSubroutesActionReturn {
  /**
   * @schema VirtualServerRouteSpecSubroutesActionReturn#body
   */
  readonly body?: string;

  /**
   * @schema VirtualServerRouteSpecSubroutesActionReturn#code
   */
  readonly code?: number;

  /**
   * @schema VirtualServerRouteSpecSubroutesActionReturn#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesActionReturn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesActionReturn(obj: VirtualServerRouteSpecSubroutesActionReturn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'body': obj.body,
    'code': obj.code,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ErrorPageRedirect defines a redirect for an ErrorPage.
 *
 * @schema VirtualServerRouteSpecSubroutesErrorPagesRedirect
 */
export interface VirtualServerRouteSpecSubroutesErrorPagesRedirect {
  /**
   * @schema VirtualServerRouteSpecSubroutesErrorPagesRedirect#code
   */
  readonly code?: number;

  /**
   * @schema VirtualServerRouteSpecSubroutesErrorPagesRedirect#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesErrorPagesRedirect' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesErrorPagesRedirect(obj: VirtualServerRouteSpecSubroutesErrorPagesRedirect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'code': obj.code,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ErrorPageReturn defines a return for an ErrorPage.
 *
 * @schema VirtualServerRouteSpecSubroutesErrorPagesReturn
 */
export interface VirtualServerRouteSpecSubroutesErrorPagesReturn {
  /**
   * @schema VirtualServerRouteSpecSubroutesErrorPagesReturn#body
   */
  readonly body?: string;

  /**
   * @schema VirtualServerRouteSpecSubroutesErrorPagesReturn#code
   */
  readonly code?: number;

  /**
   * @schema VirtualServerRouteSpecSubroutesErrorPagesReturn#headers
   */
  readonly headers?: VirtualServerRouteSpecSubroutesErrorPagesReturnHeaders[];

  /**
   * @schema VirtualServerRouteSpecSubroutesErrorPagesReturn#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesErrorPagesReturn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesErrorPagesReturn(obj: VirtualServerRouteSpecSubroutesErrorPagesReturn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'body': obj.body,
    'code': obj.code,
    'headers': obj.headers?.map(y => toJson_VirtualServerRouteSpecSubroutesErrorPagesReturnHeaders(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Action defines an action.
 *
 * @schema VirtualServerRouteSpecSubroutesMatchesAction
 */
export interface VirtualServerRouteSpecSubroutesMatchesAction {
  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesAction#pass
   */
  readonly pass?: string;

  /**
   * ActionProxy defines a proxy in an Action.
   *
   * @schema VirtualServerRouteSpecSubroutesMatchesAction#proxy
   */
  readonly proxy?: VirtualServerRouteSpecSubroutesMatchesActionProxy;

  /**
   * ActionRedirect defines a redirect in an Action.
   *
   * @schema VirtualServerRouteSpecSubroutesMatchesAction#redirect
   */
  readonly redirect?: VirtualServerRouteSpecSubroutesMatchesActionRedirect;

  /**
   * ActionReturn defines a return in an Action.
   *
   * @schema VirtualServerRouteSpecSubroutesMatchesAction#return
   */
  readonly return?: VirtualServerRouteSpecSubroutesMatchesActionReturn;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesMatchesAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesMatchesAction(obj: VirtualServerRouteSpecSubroutesMatchesAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pass': obj.pass,
    'proxy': toJson_VirtualServerRouteSpecSubroutesMatchesActionProxy(obj.proxy),
    'redirect': toJson_VirtualServerRouteSpecSubroutesMatchesActionRedirect(obj.redirect),
    'return': toJson_VirtualServerRouteSpecSubroutesMatchesActionReturn(obj.return),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Condition defines a condition in a MatchRule.
 *
 * @schema VirtualServerRouteSpecSubroutesMatchesConditions
 */
export interface VirtualServerRouteSpecSubroutesMatchesConditions {
  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesConditions#argument
   */
  readonly argument?: string;

  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesConditions#cookie
   */
  readonly cookie?: string;

  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesConditions#header
   */
  readonly header?: string;

  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesConditions#value
   */
  readonly value?: string;

  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesConditions#variable
   */
  readonly variable?: string;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesMatchesConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesMatchesConditions(obj: VirtualServerRouteSpecSubroutesMatchesConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'argument': obj.argument,
    'cookie': obj.cookie,
    'header': obj.header,
    'value': obj.value,
    'variable': obj.variable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Split defines a split.
 *
 * @schema VirtualServerRouteSpecSubroutesMatchesSplits
 */
export interface VirtualServerRouteSpecSubroutesMatchesSplits {
  /**
   * Action defines an action.
   *
   * @schema VirtualServerRouteSpecSubroutesMatchesSplits#action
   */
  readonly action?: VirtualServerRouteSpecSubroutesMatchesSplitsAction;

  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesSplits#weight
   */
  readonly weight?: number;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesMatchesSplits' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesMatchesSplits(obj: VirtualServerRouteSpecSubroutesMatchesSplits | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': toJson_VirtualServerRouteSpecSubroutesMatchesSplitsAction(obj.action),
    'weight': obj.weight,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Action defines an action.
 *
 * @schema VirtualServerRouteSpecSubroutesSplitsAction
 */
export interface VirtualServerRouteSpecSubroutesSplitsAction {
  /**
   * @schema VirtualServerRouteSpecSubroutesSplitsAction#pass
   */
  readonly pass?: string;

  /**
   * ActionProxy defines a proxy in an Action.
   *
   * @schema VirtualServerRouteSpecSubroutesSplitsAction#proxy
   */
  readonly proxy?: VirtualServerRouteSpecSubroutesSplitsActionProxy;

  /**
   * ActionRedirect defines a redirect in an Action.
   *
   * @schema VirtualServerRouteSpecSubroutesSplitsAction#redirect
   */
  readonly redirect?: VirtualServerRouteSpecSubroutesSplitsActionRedirect;

  /**
   * ActionReturn defines a return in an Action.
   *
   * @schema VirtualServerRouteSpecSubroutesSplitsAction#return
   */
  readonly return?: VirtualServerRouteSpecSubroutesSplitsActionReturn;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesSplitsAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesSplitsAction(obj: VirtualServerRouteSpecSubroutesSplitsAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pass': obj.pass,
    'proxy': toJson_VirtualServerRouteSpecSubroutesSplitsActionProxy(obj.proxy),
    'redirect': toJson_VirtualServerRouteSpecSubroutesSplitsActionRedirect(obj.redirect),
    'return': toJson_VirtualServerRouteSpecSubroutesSplitsActionReturn(obj.return),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Header defines an HTTP Header.
 *
 * @schema VirtualServerRouteSpecUpstreamsHealthCheckHeaders
 */
export interface VirtualServerRouteSpecUpstreamsHealthCheckHeaders {
  /**
   * @schema VirtualServerRouteSpecUpstreamsHealthCheckHeaders#name
   */
  readonly name?: string;

  /**
   * @schema VirtualServerRouteSpecUpstreamsHealthCheckHeaders#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecUpstreamsHealthCheckHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecUpstreamsHealthCheckHeaders(obj: VirtualServerRouteSpecUpstreamsHealthCheckHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * UpstreamTLS defines a TLS configuration for an Upstream.
 *
 * @schema VirtualServerRouteSpecUpstreamsHealthCheckTls
 */
export interface VirtualServerRouteSpecUpstreamsHealthCheckTls {
  /**
   * @schema VirtualServerRouteSpecUpstreamsHealthCheckTls#enable
   */
  readonly enable?: boolean;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecUpstreamsHealthCheckTls' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecUpstreamsHealthCheckTls(obj: VirtualServerRouteSpecUpstreamsHealthCheckTls | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enable': obj.enable,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProxyRequestHeaders defines the request headers manipulation in an ActionProxy.
 *
 * @schema VirtualServerRouteSpecSubroutesActionProxyRequestHeaders
 */
export interface VirtualServerRouteSpecSubroutesActionProxyRequestHeaders {
  /**
   * @schema VirtualServerRouteSpecSubroutesActionProxyRequestHeaders#pass
   */
  readonly pass?: boolean;

  /**
   * @schema VirtualServerRouteSpecSubroutesActionProxyRequestHeaders#set
   */
  readonly set?: VirtualServerRouteSpecSubroutesActionProxyRequestHeadersSet[];

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesActionProxyRequestHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesActionProxyRequestHeaders(obj: VirtualServerRouteSpecSubroutesActionProxyRequestHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pass': obj.pass,
    'set': obj.set?.map(y => toJson_VirtualServerRouteSpecSubroutesActionProxyRequestHeadersSet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProxyResponseHeaders defines the response headers manipulation in an ActionProxy.
 *
 * @schema VirtualServerRouteSpecSubroutesActionProxyResponseHeaders
 */
export interface VirtualServerRouteSpecSubroutesActionProxyResponseHeaders {
  /**
   * @schema VirtualServerRouteSpecSubroutesActionProxyResponseHeaders#add
   */
  readonly add?: VirtualServerRouteSpecSubroutesActionProxyResponseHeadersAdd[];

  /**
   * @schema VirtualServerRouteSpecSubroutesActionProxyResponseHeaders#hide
   */
  readonly hide?: string[];

  /**
   * @schema VirtualServerRouteSpecSubroutesActionProxyResponseHeaders#ignore
   */
  readonly ignore?: string[];

  /**
   * @schema VirtualServerRouteSpecSubroutesActionProxyResponseHeaders#pass
   */
  readonly pass?: string[];

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesActionProxyResponseHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesActionProxyResponseHeaders(obj: VirtualServerRouteSpecSubroutesActionProxyResponseHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => toJson_VirtualServerRouteSpecSubroutesActionProxyResponseHeadersAdd(y)),
    'hide': obj.hide?.map(y => y),
    'ignore': obj.ignore?.map(y => y),
    'pass': obj.pass?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Header defines an HTTP Header.
 *
 * @schema VirtualServerRouteSpecSubroutesErrorPagesReturnHeaders
 */
export interface VirtualServerRouteSpecSubroutesErrorPagesReturnHeaders {
  /**
   * @schema VirtualServerRouteSpecSubroutesErrorPagesReturnHeaders#name
   */
  readonly name?: string;

  /**
   * @schema VirtualServerRouteSpecSubroutesErrorPagesReturnHeaders#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesErrorPagesReturnHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesErrorPagesReturnHeaders(obj: VirtualServerRouteSpecSubroutesErrorPagesReturnHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ActionProxy defines a proxy in an Action.
 *
 * @schema VirtualServerRouteSpecSubroutesMatchesActionProxy
 */
export interface VirtualServerRouteSpecSubroutesMatchesActionProxy {
  /**
   * ProxyRequestHeaders defines the request headers manipulation in an ActionProxy.
   *
   * @schema VirtualServerRouteSpecSubroutesMatchesActionProxy#requestHeaders
   */
  readonly requestHeaders?: VirtualServerRouteSpecSubroutesMatchesActionProxyRequestHeaders;

  /**
   * ProxyResponseHeaders defines the response headers manipulation in an ActionProxy.
   *
   * @schema VirtualServerRouteSpecSubroutesMatchesActionProxy#responseHeaders
   */
  readonly responseHeaders?: VirtualServerRouteSpecSubroutesMatchesActionProxyResponseHeaders;

  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesActionProxy#rewritePath
   */
  readonly rewritePath?: string;

  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesActionProxy#upstream
   */
  readonly upstream?: string;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesMatchesActionProxy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesMatchesActionProxy(obj: VirtualServerRouteSpecSubroutesMatchesActionProxy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'requestHeaders': toJson_VirtualServerRouteSpecSubroutesMatchesActionProxyRequestHeaders(obj.requestHeaders),
    'responseHeaders': toJson_VirtualServerRouteSpecSubroutesMatchesActionProxyResponseHeaders(obj.responseHeaders),
    'rewritePath': obj.rewritePath,
    'upstream': obj.upstream,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ActionRedirect defines a redirect in an Action.
 *
 * @schema VirtualServerRouteSpecSubroutesMatchesActionRedirect
 */
export interface VirtualServerRouteSpecSubroutesMatchesActionRedirect {
  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesActionRedirect#code
   */
  readonly code?: number;

  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesActionRedirect#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesMatchesActionRedirect' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesMatchesActionRedirect(obj: VirtualServerRouteSpecSubroutesMatchesActionRedirect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'code': obj.code,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ActionReturn defines a return in an Action.
 *
 * @schema VirtualServerRouteSpecSubroutesMatchesActionReturn
 */
export interface VirtualServerRouteSpecSubroutesMatchesActionReturn {
  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesActionReturn#body
   */
  readonly body?: string;

  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesActionReturn#code
   */
  readonly code?: number;

  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesActionReturn#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesMatchesActionReturn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesMatchesActionReturn(obj: VirtualServerRouteSpecSubroutesMatchesActionReturn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'body': obj.body,
    'code': obj.code,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Action defines an action.
 *
 * @schema VirtualServerRouteSpecSubroutesMatchesSplitsAction
 */
export interface VirtualServerRouteSpecSubroutesMatchesSplitsAction {
  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesSplitsAction#pass
   */
  readonly pass?: string;

  /**
   * ActionProxy defines a proxy in an Action.
   *
   * @schema VirtualServerRouteSpecSubroutesMatchesSplitsAction#proxy
   */
  readonly proxy?: VirtualServerRouteSpecSubroutesMatchesSplitsActionProxy;

  /**
   * ActionRedirect defines a redirect in an Action.
   *
   * @schema VirtualServerRouteSpecSubroutesMatchesSplitsAction#redirect
   */
  readonly redirect?: VirtualServerRouteSpecSubroutesMatchesSplitsActionRedirect;

  /**
   * ActionReturn defines a return in an Action.
   *
   * @schema VirtualServerRouteSpecSubroutesMatchesSplitsAction#return
   */
  readonly return?: VirtualServerRouteSpecSubroutesMatchesSplitsActionReturn;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesMatchesSplitsAction' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesMatchesSplitsAction(obj: VirtualServerRouteSpecSubroutesMatchesSplitsAction | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pass': obj.pass,
    'proxy': toJson_VirtualServerRouteSpecSubroutesMatchesSplitsActionProxy(obj.proxy),
    'redirect': toJson_VirtualServerRouteSpecSubroutesMatchesSplitsActionRedirect(obj.redirect),
    'return': toJson_VirtualServerRouteSpecSubroutesMatchesSplitsActionReturn(obj.return),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ActionProxy defines a proxy in an Action.
 *
 * @schema VirtualServerRouteSpecSubroutesSplitsActionProxy
 */
export interface VirtualServerRouteSpecSubroutesSplitsActionProxy {
  /**
   * ProxyRequestHeaders defines the request headers manipulation in an ActionProxy.
   *
   * @schema VirtualServerRouteSpecSubroutesSplitsActionProxy#requestHeaders
   */
  readonly requestHeaders?: VirtualServerRouteSpecSubroutesSplitsActionProxyRequestHeaders;

  /**
   * ProxyResponseHeaders defines the response headers manipulation in an ActionProxy.
   *
   * @schema VirtualServerRouteSpecSubroutesSplitsActionProxy#responseHeaders
   */
  readonly responseHeaders?: VirtualServerRouteSpecSubroutesSplitsActionProxyResponseHeaders;

  /**
   * @schema VirtualServerRouteSpecSubroutesSplitsActionProxy#rewritePath
   */
  readonly rewritePath?: string;

  /**
   * @schema VirtualServerRouteSpecSubroutesSplitsActionProxy#upstream
   */
  readonly upstream?: string;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesSplitsActionProxy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesSplitsActionProxy(obj: VirtualServerRouteSpecSubroutesSplitsActionProxy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'requestHeaders': toJson_VirtualServerRouteSpecSubroutesSplitsActionProxyRequestHeaders(obj.requestHeaders),
    'responseHeaders': toJson_VirtualServerRouteSpecSubroutesSplitsActionProxyResponseHeaders(obj.responseHeaders),
    'rewritePath': obj.rewritePath,
    'upstream': obj.upstream,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ActionRedirect defines a redirect in an Action.
 *
 * @schema VirtualServerRouteSpecSubroutesSplitsActionRedirect
 */
export interface VirtualServerRouteSpecSubroutesSplitsActionRedirect {
  /**
   * @schema VirtualServerRouteSpecSubroutesSplitsActionRedirect#code
   */
  readonly code?: number;

  /**
   * @schema VirtualServerRouteSpecSubroutesSplitsActionRedirect#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesSplitsActionRedirect' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesSplitsActionRedirect(obj: VirtualServerRouteSpecSubroutesSplitsActionRedirect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'code': obj.code,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ActionReturn defines a return in an Action.
 *
 * @schema VirtualServerRouteSpecSubroutesSplitsActionReturn
 */
export interface VirtualServerRouteSpecSubroutesSplitsActionReturn {
  /**
   * @schema VirtualServerRouteSpecSubroutesSplitsActionReturn#body
   */
  readonly body?: string;

  /**
   * @schema VirtualServerRouteSpecSubroutesSplitsActionReturn#code
   */
  readonly code?: number;

  /**
   * @schema VirtualServerRouteSpecSubroutesSplitsActionReturn#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesSplitsActionReturn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesSplitsActionReturn(obj: VirtualServerRouteSpecSubroutesSplitsActionReturn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'body': obj.body,
    'code': obj.code,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Header defines an HTTP Header.
 *
 * @schema VirtualServerRouteSpecSubroutesActionProxyRequestHeadersSet
 */
export interface VirtualServerRouteSpecSubroutesActionProxyRequestHeadersSet {
  /**
   * @schema VirtualServerRouteSpecSubroutesActionProxyRequestHeadersSet#name
   */
  readonly name?: string;

  /**
   * @schema VirtualServerRouteSpecSubroutesActionProxyRequestHeadersSet#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesActionProxyRequestHeadersSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesActionProxyRequestHeadersSet(obj: VirtualServerRouteSpecSubroutesActionProxyRequestHeadersSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AddHeader defines an HTTP Header with an optional Always field to use with the add_header NGINX directive.
 *
 * @schema VirtualServerRouteSpecSubroutesActionProxyResponseHeadersAdd
 */
export interface VirtualServerRouteSpecSubroutesActionProxyResponseHeadersAdd {
  /**
   * @schema VirtualServerRouteSpecSubroutesActionProxyResponseHeadersAdd#always
   */
  readonly always?: boolean;

  /**
   * @schema VirtualServerRouteSpecSubroutesActionProxyResponseHeadersAdd#name
   */
  readonly name?: string;

  /**
   * @schema VirtualServerRouteSpecSubroutesActionProxyResponseHeadersAdd#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesActionProxyResponseHeadersAdd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesActionProxyResponseHeadersAdd(obj: VirtualServerRouteSpecSubroutesActionProxyResponseHeadersAdd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'always': obj.always,
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProxyRequestHeaders defines the request headers manipulation in an ActionProxy.
 *
 * @schema VirtualServerRouteSpecSubroutesMatchesActionProxyRequestHeaders
 */
export interface VirtualServerRouteSpecSubroutesMatchesActionProxyRequestHeaders {
  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesActionProxyRequestHeaders#pass
   */
  readonly pass?: boolean;

  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesActionProxyRequestHeaders#set
   */
  readonly set?: VirtualServerRouteSpecSubroutesMatchesActionProxyRequestHeadersSet[];

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesMatchesActionProxyRequestHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesMatchesActionProxyRequestHeaders(obj: VirtualServerRouteSpecSubroutesMatchesActionProxyRequestHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pass': obj.pass,
    'set': obj.set?.map(y => toJson_VirtualServerRouteSpecSubroutesMatchesActionProxyRequestHeadersSet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProxyResponseHeaders defines the response headers manipulation in an ActionProxy.
 *
 * @schema VirtualServerRouteSpecSubroutesMatchesActionProxyResponseHeaders
 */
export interface VirtualServerRouteSpecSubroutesMatchesActionProxyResponseHeaders {
  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesActionProxyResponseHeaders#add
   */
  readonly add?: VirtualServerRouteSpecSubroutesMatchesActionProxyResponseHeadersAdd[];

  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesActionProxyResponseHeaders#hide
   */
  readonly hide?: string[];

  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesActionProxyResponseHeaders#ignore
   */
  readonly ignore?: string[];

  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesActionProxyResponseHeaders#pass
   */
  readonly pass?: string[];

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesMatchesActionProxyResponseHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesMatchesActionProxyResponseHeaders(obj: VirtualServerRouteSpecSubroutesMatchesActionProxyResponseHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => toJson_VirtualServerRouteSpecSubroutesMatchesActionProxyResponseHeadersAdd(y)),
    'hide': obj.hide?.map(y => y),
    'ignore': obj.ignore?.map(y => y),
    'pass': obj.pass?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ActionProxy defines a proxy in an Action.
 *
 * @schema VirtualServerRouteSpecSubroutesMatchesSplitsActionProxy
 */
export interface VirtualServerRouteSpecSubroutesMatchesSplitsActionProxy {
  /**
   * ProxyRequestHeaders defines the request headers manipulation in an ActionProxy.
   *
   * @schema VirtualServerRouteSpecSubroutesMatchesSplitsActionProxy#requestHeaders
   */
  readonly requestHeaders?: VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyRequestHeaders;

  /**
   * ProxyResponseHeaders defines the response headers manipulation in an ActionProxy.
   *
   * @schema VirtualServerRouteSpecSubroutesMatchesSplitsActionProxy#responseHeaders
   */
  readonly responseHeaders?: VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyResponseHeaders;

  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesSplitsActionProxy#rewritePath
   */
  readonly rewritePath?: string;

  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesSplitsActionProxy#upstream
   */
  readonly upstream?: string;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesMatchesSplitsActionProxy' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesMatchesSplitsActionProxy(obj: VirtualServerRouteSpecSubroutesMatchesSplitsActionProxy | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'requestHeaders': toJson_VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyRequestHeaders(obj.requestHeaders),
    'responseHeaders': toJson_VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyResponseHeaders(obj.responseHeaders),
    'rewritePath': obj.rewritePath,
    'upstream': obj.upstream,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ActionRedirect defines a redirect in an Action.
 *
 * @schema VirtualServerRouteSpecSubroutesMatchesSplitsActionRedirect
 */
export interface VirtualServerRouteSpecSubroutesMatchesSplitsActionRedirect {
  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesSplitsActionRedirect#code
   */
  readonly code?: number;

  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesSplitsActionRedirect#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesMatchesSplitsActionRedirect' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesMatchesSplitsActionRedirect(obj: VirtualServerRouteSpecSubroutesMatchesSplitsActionRedirect | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'code': obj.code,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ActionReturn defines a return in an Action.
 *
 * @schema VirtualServerRouteSpecSubroutesMatchesSplitsActionReturn
 */
export interface VirtualServerRouteSpecSubroutesMatchesSplitsActionReturn {
  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesSplitsActionReturn#body
   */
  readonly body?: string;

  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesSplitsActionReturn#code
   */
  readonly code?: number;

  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesSplitsActionReturn#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesMatchesSplitsActionReturn' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesMatchesSplitsActionReturn(obj: VirtualServerRouteSpecSubroutesMatchesSplitsActionReturn | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'body': obj.body,
    'code': obj.code,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProxyRequestHeaders defines the request headers manipulation in an ActionProxy.
 *
 * @schema VirtualServerRouteSpecSubroutesSplitsActionProxyRequestHeaders
 */
export interface VirtualServerRouteSpecSubroutesSplitsActionProxyRequestHeaders {
  /**
   * @schema VirtualServerRouteSpecSubroutesSplitsActionProxyRequestHeaders#pass
   */
  readonly pass?: boolean;

  /**
   * @schema VirtualServerRouteSpecSubroutesSplitsActionProxyRequestHeaders#set
   */
  readonly set?: VirtualServerRouteSpecSubroutesSplitsActionProxyRequestHeadersSet[];

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesSplitsActionProxyRequestHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesSplitsActionProxyRequestHeaders(obj: VirtualServerRouteSpecSubroutesSplitsActionProxyRequestHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pass': obj.pass,
    'set': obj.set?.map(y => toJson_VirtualServerRouteSpecSubroutesSplitsActionProxyRequestHeadersSet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProxyResponseHeaders defines the response headers manipulation in an ActionProxy.
 *
 * @schema VirtualServerRouteSpecSubroutesSplitsActionProxyResponseHeaders
 */
export interface VirtualServerRouteSpecSubroutesSplitsActionProxyResponseHeaders {
  /**
   * @schema VirtualServerRouteSpecSubroutesSplitsActionProxyResponseHeaders#add
   */
  readonly add?: VirtualServerRouteSpecSubroutesSplitsActionProxyResponseHeadersAdd[];

  /**
   * @schema VirtualServerRouteSpecSubroutesSplitsActionProxyResponseHeaders#hide
   */
  readonly hide?: string[];

  /**
   * @schema VirtualServerRouteSpecSubroutesSplitsActionProxyResponseHeaders#ignore
   */
  readonly ignore?: string[];

  /**
   * @schema VirtualServerRouteSpecSubroutesSplitsActionProxyResponseHeaders#pass
   */
  readonly pass?: string[];

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesSplitsActionProxyResponseHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesSplitsActionProxyResponseHeaders(obj: VirtualServerRouteSpecSubroutesSplitsActionProxyResponseHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => toJson_VirtualServerRouteSpecSubroutesSplitsActionProxyResponseHeadersAdd(y)),
    'hide': obj.hide?.map(y => y),
    'ignore': obj.ignore?.map(y => y),
    'pass': obj.pass?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Header defines an HTTP Header.
 *
 * @schema VirtualServerRouteSpecSubroutesMatchesActionProxyRequestHeadersSet
 */
export interface VirtualServerRouteSpecSubroutesMatchesActionProxyRequestHeadersSet {
  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesActionProxyRequestHeadersSet#name
   */
  readonly name?: string;

  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesActionProxyRequestHeadersSet#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesMatchesActionProxyRequestHeadersSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesMatchesActionProxyRequestHeadersSet(obj: VirtualServerRouteSpecSubroutesMatchesActionProxyRequestHeadersSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AddHeader defines an HTTP Header with an optional Always field to use with the add_header NGINX directive.
 *
 * @schema VirtualServerRouteSpecSubroutesMatchesActionProxyResponseHeadersAdd
 */
export interface VirtualServerRouteSpecSubroutesMatchesActionProxyResponseHeadersAdd {
  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesActionProxyResponseHeadersAdd#always
   */
  readonly always?: boolean;

  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesActionProxyResponseHeadersAdd#name
   */
  readonly name?: string;

  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesActionProxyResponseHeadersAdd#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesMatchesActionProxyResponseHeadersAdd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesMatchesActionProxyResponseHeadersAdd(obj: VirtualServerRouteSpecSubroutesMatchesActionProxyResponseHeadersAdd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'always': obj.always,
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProxyRequestHeaders defines the request headers manipulation in an ActionProxy.
 *
 * @schema VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyRequestHeaders
 */
export interface VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyRequestHeaders {
  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyRequestHeaders#pass
   */
  readonly pass?: boolean;

  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyRequestHeaders#set
   */
  readonly set?: VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyRequestHeadersSet[];

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyRequestHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyRequestHeaders(obj: VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyRequestHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'pass': obj.pass,
    'set': obj.set?.map(y => toJson_VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyRequestHeadersSet(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ProxyResponseHeaders defines the response headers manipulation in an ActionProxy.
 *
 * @schema VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyResponseHeaders
 */
export interface VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyResponseHeaders {
  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyResponseHeaders#add
   */
  readonly add?: VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyResponseHeadersAdd[];

  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyResponseHeaders#hide
   */
  readonly hide?: string[];

  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyResponseHeaders#ignore
   */
  readonly ignore?: string[];

  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyResponseHeaders#pass
   */
  readonly pass?: string[];

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyResponseHeaders' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyResponseHeaders(obj: VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyResponseHeaders | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'add': obj.add?.map(y => toJson_VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyResponseHeadersAdd(y)),
    'hide': obj.hide?.map(y => y),
    'ignore': obj.ignore?.map(y => y),
    'pass': obj.pass?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Header defines an HTTP Header.
 *
 * @schema VirtualServerRouteSpecSubroutesSplitsActionProxyRequestHeadersSet
 */
export interface VirtualServerRouteSpecSubroutesSplitsActionProxyRequestHeadersSet {
  /**
   * @schema VirtualServerRouteSpecSubroutesSplitsActionProxyRequestHeadersSet#name
   */
  readonly name?: string;

  /**
   * @schema VirtualServerRouteSpecSubroutesSplitsActionProxyRequestHeadersSet#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesSplitsActionProxyRequestHeadersSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesSplitsActionProxyRequestHeadersSet(obj: VirtualServerRouteSpecSubroutesSplitsActionProxyRequestHeadersSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AddHeader defines an HTTP Header with an optional Always field to use with the add_header NGINX directive.
 *
 * @schema VirtualServerRouteSpecSubroutesSplitsActionProxyResponseHeadersAdd
 */
export interface VirtualServerRouteSpecSubroutesSplitsActionProxyResponseHeadersAdd {
  /**
   * @schema VirtualServerRouteSpecSubroutesSplitsActionProxyResponseHeadersAdd#always
   */
  readonly always?: boolean;

  /**
   * @schema VirtualServerRouteSpecSubroutesSplitsActionProxyResponseHeadersAdd#name
   */
  readonly name?: string;

  /**
   * @schema VirtualServerRouteSpecSubroutesSplitsActionProxyResponseHeadersAdd#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesSplitsActionProxyResponseHeadersAdd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesSplitsActionProxyResponseHeadersAdd(obj: VirtualServerRouteSpecSubroutesSplitsActionProxyResponseHeadersAdd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'always': obj.always,
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Header defines an HTTP Header.
 *
 * @schema VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyRequestHeadersSet
 */
export interface VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyRequestHeadersSet {
  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyRequestHeadersSet#name
   */
  readonly name?: string;

  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyRequestHeadersSet#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyRequestHeadersSet' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyRequestHeadersSet(obj: VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyRequestHeadersSet | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AddHeader defines an HTTP Header with an optional Always field to use with the add_header NGINX directive.
 *
 * @schema VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyResponseHeadersAdd
 */
export interface VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyResponseHeadersAdd {
  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyResponseHeadersAdd#always
   */
  readonly always?: boolean;

  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyResponseHeadersAdd#name
   */
  readonly name?: string;

  /**
   * @schema VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyResponseHeadersAdd#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyResponseHeadersAdd' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyResponseHeadersAdd(obj: VirtualServerRouteSpecSubroutesMatchesSplitsActionProxyResponseHeadersAdd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'always': obj.always,
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

